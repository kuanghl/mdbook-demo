
msgid ""
msgstr ""
"Project-Id-Version: mdbook-demo\n"
"POT-Creation-Date: 2025-04-12T15:49:43+08:00\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh-Hans\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ./src/SUMMARY.md:1
msgid "Summary"
msgstr ""

#: ./src/SUMMARY.md:4 ./src/test/chapter_1.md:58
msgid "mdbook_mathjax"
msgstr ""

#: ./src/SUMMARY.md:5
msgid "pybind11"
msgstr ""

#: ./src/SUMMARY.md:6 ./src/3rd/pybind11/01.改动日志.md:58
msgid "改动日志"
msgstr ""

#: ./src/SUMMARY.md:7 ./src/3rd/pybind11/02.更新指南.md:58
msgid "更新指南"
msgstr ""

#: ./src/SUMMARY.md:8
msgid "安装说明"
msgstr ""

#: ./src/SUMMARY.md:9
msgid "首次尝试"
msgstr ""

#: ./src/SUMMARY.md:10
msgid "面对对象编程"
msgstr ""

#: ./src/SUMMARY.md:11
msgid "构建系统"
msgstr ""

#: ./src/SUMMARY.md:12
msgid "函数"
msgstr ""

#: ./src/SUMMARY.md:13
msgid "类"
msgstr ""

#: ./src/SUMMARY.md:14
msgid "异常"
msgstr ""

#: ./src/SUMMARY.md:15
msgid "智能指针"
msgstr ""

#: ./src/SUMMARY.md:16
msgid "类型转换"
msgstr ""

#: ./src/SUMMARY.md:17
msgid "Python的C++接口"
msgstr ""

#: ./src/SUMMARY.md:18
msgid "内嵌解释器"
msgstr ""

#: ./src/SUMMARY.md:19
msgid "杂项"
msgstr ""

#: ./src/SUMMARY.md:20
msgid "FAQ"
msgstr ""

#: ./src/SUMMARY.md:21
msgid "案例"
msgstr ""

#: ./src/SUMMARY.md:22
msgid "pybind11 demo"
msgstr ""

#: ./src/SUMMARY.md:23
msgid "markdown"
msgstr ""

#: ./src/SUMMARY.md:24
msgid "admonish"
msgstr ""

#: ./src/SUMMARY.md:25
msgid "Katex"
msgstr ""

#: ./src/SUMMARY.md:26
msgid "whichlang"
msgstr ""

#: ./src/SUMMARY.md:27
msgid "langtabs"
msgstr ""

#: ./src/SUMMARY.md:28 ./src/test/chapter_2.md:58
msgid "kroki-mermaid"
msgstr ""

#: ./src/test/chapter_1.md:60 ./src/test/chapter_1.md:66
#: ./src/test/chapter_1.md:72 ./src/test/chapter_1.md:78
#: ./src/test/chapter_1.md:84 ./src/test/chapter_1.md:92
msgid "Section 1"
msgstr ""

#: ./src/test/chapter_1.md:62 ./src/test/chapter_1.md:68
#: ./src/test/chapter_1.md:74 ./src/test/chapter_1.md:80
#: ./src/test/chapter_1.md:86 ./src/test/chapter_1.md:109
msgid "Section 2"
msgstr ""

#: ./src/test/chapter_1.md:64
msgid "Chapter 2"
msgstr ""

#: ./src/test/chapter_1.md:70
msgid "Chapter 3"
msgstr ""

#: ./src/test/chapter_1.md:76
msgid "Chapter 4"
msgstr ""

#: ./src/test/chapter_1.md:82
msgid "Chapter 5"
msgstr ""

#: ./src/test/chapter_1.md:90
msgid "Chapter 6"
msgstr ""

#: ./src/test/chapter_1.md:94
msgid ""
"\\[!NOTE\\]  \n"
"Highlights information that users should take into account, even when "
"skimming."
msgstr ""

#: ./src/test/chapter_1.md:97
msgid "\\[!TIP\\] Optional information to help a user be more successful."
msgstr ""

#: ./src/test/chapter_1.md:100
msgid "\\[!IMPORTANT\\]  \nCrucial information necessary for users to succeed."
msgstr ""

#: ./src/test/chapter_1.md:103
msgid ""
"\\[!WARNING\\]  \n"
"Critical content demanding immediate user attention due to potential risks."
msgstr ""

#: ./src/test/chapter_1.md:106
msgid "\\[!CAUTION\\] Negative potential consequences of an action."
msgstr ""

#: ./src/test/chapter_1.md:112
msgid "Here is an inline example, "
msgstr ""

#: ./src/test/chapter_1.md:112
msgid "π"
msgstr ""

#: ./src/test/chapter_1.md:112 ./src/test/chapter_1.md:116
#: ./src/test/chapter_1.md:120 ./src/test/chapter_1.md:122
#: ./src/test/chapter_3.md:66 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:81
#: ./src/test/chapter_3.md:81 ./src/test/chapter_3.md:81
#: ./src/test/chapter_3.md:81 ./src/test/chapter_3.md:87
#: ./src/test/chapter_3.md:87 ./src/test/chapter_3.md:87
msgid "("
msgstr ""

#: ./src/test/chapter_1.md:112 ./src/test/chapter_3.md:62
#: ./src/test/chapter_3.md:62 ./src/test/chapter_3.md:62
#: ./src/test/chapter_3.md:62
msgid "θ"
msgstr ""

#: ./src/test/chapter_1.md:112 ./src/test/chapter_1.md:116
#: ./src/test/chapter_1.md:120 ./src/test/chapter_1.md:122
#: ./src/test/chapter_3.md:66 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:81
#: ./src/test/chapter_3.md:81 ./src/test/chapter_3.md:81
#: ./src/test/chapter_3.md:81 ./src/test/chapter_3.md:87
#: ./src/test/chapter_3.md:87 ./src/test/chapter_3.md:87
msgid ")"
msgstr ""

#: ./src/test/chapter_1.md:112 ./src/test/chapter_1.md:116
#: ./src/test/chapter_3.md:66
msgid ","
msgstr ""

#: ./src/test/chapter_1.md:114
msgid "an equation,"
msgstr ""

#: ./src/test/chapter_1.md:116
msgid "∇"
msgstr ""

#: ./src/test/chapter_1.md:116 ./src/test/chapter_1.md:120
#: ./src/test/chapter_1.md:122 ./src/test/chapter_3.md:66
#: ./src/test/chapter_3.md:81 ./src/test/chapter_3.md:81
msgid "f"
msgstr ""

#: ./src/test/chapter_1.md:116 ./src/test/chapter_1.md:120
#: ./src/test/chapter_1.md:122 ./src/test/chapter_1.md:122
#: ./src/test/chapter_1.md:122 ./src/test/chapter_3.md:62
#: ./src/test/chapter_3.md:66 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74
msgid "x"
msgstr ""

#: ./src/test/chapter_1.md:116 ./src/test/chapter_1.md:122
msgid "∈"
msgstr ""

#: ./src/test/chapter_1.md:116 ./src/test/chapter_1.md:122
msgid "R"
msgstr ""

#: ./src/test/chapter_1.md:116 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
msgid "n"
msgstr ""

#: ./src/test/chapter_1.md:118
msgid "and a regular $ symbol."
msgstr ""

#: ./src/test/chapter_1.md:120
msgid "Define "
msgstr ""

#: ./src/test/chapter_1.md:120
msgid ":"
msgstr ""

#: ./src/test/chapter_1.md:122 ./src/test/chapter_3.md:62
#: ./src/test/chapter_3.md:62 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:81
#: ./src/test/chapter_3.md:81 ./src/test/chapter_3.md:87
#: ./src/test/chapter_3.md:87 ./src/test/chapter_3.md:87
msgid "="
msgstr ""

#: ./src/test/chapter_1.md:122 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:87
msgid "2"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:58
msgid "pybind11——无缝连接C+11和Python"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:60
msgid ""
"pybind11是一个只有头文件的轻量级库，它在导出C++类型到Python的同时，也导出Python类型到C++中，其主要目的是建立现有C++代码的Python绑定。它与David "
"Abrahams的Boost.Python库目的和语法相似，都是通过编译期内省来推断类型信息，以最大程度地降低传统扩展模块中的重复样板代码。"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:62
msgid ""
"Boost.Python的问题主要在于Boost本身，这也是我创建一个类似项目的原因。Boost是一套庞大且复杂的工具库，它几乎兼容所有的C++编译器。但这种兼容性是有成本的：为了支持那些极其古老且充满BUG的编译器版本，Boost不得不使用各种晦涩难懂的模板技巧与变通方法。现在，支持C++11的编译器已经被广泛使用，这种沉重结构已成为一种过大且不必要的依赖。"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:64
msgid ""
"你可以把pybind11库想象成Boost.Python的一个小型独立版本，其中所有与python绑定生成无关的内容都被删除了。不算注释，pybind11核心头文件大约只有4K行代码，并且它只依赖于Python（2.7或3.5+，或PyPy）和C "
"++标准库。由于C++11语言的新特性(特别是元组、lambda函数和可变参数模板），这种紧凑的实现才成为可能。自创建以来，这个库已经在很多方面超越了Boost.Python，多数常见情况下pybind11使得python绑定代码变得非常简单。"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:66
msgid "1.1 核心特性"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:68
msgid "pybind11可以将以下C++核心特性映射到Python："
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:70
msgid "函数入参和返回值可以是自定义数据结构的值、引用或者指针；"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:71
msgid "类成员方法和静态方法；"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:72
msgid "重载函数；"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:73
msgid "类成员变量和静态变量；"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:74
msgid "任意异常类型；"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:75
msgid "枚举；"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:76
msgid "回调函数；"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:77
msgid "迭代器和ranges；"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:78
msgid "自定义操作符；"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:79
msgid "单继承和多重继承；"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:80
msgid "STL数据结构；"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:81
msgid "智能指针；"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:82
msgid "Internal references with correct reference counting；"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:83
msgid "可以在Python中扩展带虚函数（和纯虚函数）的C++类；"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:85
msgid "1.2 好用的功能"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:87
msgid "除了上述核心功能外，pybind11还提供了一些好用的功能："
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:89
msgid "支持Python2.7, 3.5+, PyPy/PyPy3 7.3与实现无关的接口。"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:90
msgid "可以绑定带捕获参数的lambda函数，lambda捕获的数据存储生成的Python函数对象中。"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:91
msgid ""
"pybind11使用C++11移动构造函数和移动运算符，尽可能有效的转换自定义数据类型。(pybind11 uses C++11 move "
"constructors and move assignment operators whenever possible to efficiently "
"transfer custom data types.)"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:92
msgid ""
"通过Python的buffer协议，可以很轻松地获取自定义类型的内存指针。这样，我们可以很方便地在C++矩阵类型（如Eigen）和NumPy之间快速转换，而无需昂贵的拷贝操作。"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:93
msgid "pybind11可以自动将函数矢量化，以便它们透明地应用于以NumPy数组为参数的所有条目。"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:94
msgid "只需几行代码就可以支持Python基于切片的访问和赋值操作。"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:95
msgid "使用时只需要包含几个头文件即可，不用链接任何其他的库。"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:96
msgid "相比Boost.Python，生成的库文件更小，编译更快。"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:97
msgid "使用`constexpr`在编译器与计算函数签名，进一步减小了库文件大小。"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:98
msgid "可以轻松地让C++类型支持Python pickle和unpickle操作。"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:100
msgid "1.3 支持的编译器"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:102
msgid "Clang/LLVM 3.3以上 (Apple Xcode’s clang需要5.0.0以上版本)"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:103
msgid "GCC 4.8以上"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:104
msgid "Microsoft Visual Studio 2015 Update 3以上"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:105
msgid "Intel classic C++ compiler 18 or newer (ICC 20.2 tested in CI)"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:106
msgid "Cygwin/GCC (previously tested on 2.5.1)"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:107
msgid "NVCC (CUDA 11.0 tested in CI)"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:108
msgid "NVIDIA PGI (20.9 tested in CI)"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:110
msgid "1.4 关于"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:112
msgid ""
"This project was created by Wenzel Jakob. Significant features and/or "
"improvements to the code were contributed by Jonas Adler, Lori A. Burns, "
"Sylvain Corlay, Eric Cousineau, Aaron Gokaslan, Ralf Grosse-Kunstleve, Trent "
"Houliston, Axel Huebl, @hulucc, Yannick Jadoul, Sergey Lyskov Johan Mabille, "
"Tomasz Miąsko, Dean Moldovan, Ben Pritchard, Jason Rhinelander, Boris "
"Schäling, Pim Schellart, Henry Schreiner, Ivan Smirnov, Boris Staletic, and "
"Patrick Stewart."
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:114
msgid ""
"We thank Google for a generous financial contribution to the continuous "
"integration infrastructure used by this project."
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:116
msgid "1.5 贡献"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:118
msgid ""
"See the [contributing "
"guide](https://github.com/pybind/pybind11/blob/master/.github/CONTRIBUTING.md) "
"for information on building and contributing to pybind11."
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:122
msgid "1.6 License"
msgstr ""

#: ./src/3rd/pybind11/00.pybind11介绍.md:124
msgid ""
"pybind11 is provided under a BSD-style license that can be found in the "
"[LICENSE](https://github.com/pybind/pybind11/blob/master/LICENSE) file. By "
"using, distributing, or contributing to this project, you agree to the terms "
"and conditions of this license."
msgstr ""

#: ./src/3rd/pybind11/01.改动日志.md:60
msgid "主要介绍了各个发布版本增加的功能、改进点，以及修复的BUG。暂时不翻译吧，有兴趣的可以看官方文档。"
msgstr ""

#: ./src/3rd/pybind11/03.安装说明.md:58
msgid "3. 安装说明"
msgstr ""

#: ./src/3rd/pybind11/03.安装说明.md:60
msgid ""
"我们可以在[pybind/pybind11 on "
"GitHub](https://github.com/pybind/pybind11)获取到pybind11的源码。推荐pybind11开发者使用下面介绍的前三种方法之一，来获取pybind11。"
msgstr ""

#: ./src/3rd/pybind11/03.安装说明.md:62
msgid "3.1 以子模块的形式集成"
msgstr ""

#: ./src/3rd/pybind11/03.安装说明.md:64
msgid "当你的项目使用Git管理时，你可以将pybind11当做一个子模块嵌入到你的项目中。在你的git仓库，使用以下命令即可包含pybind11："
msgstr ""

#: ./src/3rd/pybind11/03.安装说明.md:71
msgid ""
"这里假设你将项目的依赖放在了`extern`目录下，并且使用GitHub。如果你没有使用GitHub，可以使用完整的https或ssh "
"URL来代替上面的相对URL`../../pybind/pybind11`。一些服务器可能需要`.git`扩展（GitHub不用）。"
msgstr ""

#: ./src/3rd/pybind11/03.安装说明.md:73
msgid ""
"到这一步后，你可以直接include `extern/pybind11/include`目录即可。或者，你可以使用各种集成工具（见Build "
"System一章)来包含pybind11。"
msgstr ""

#: ./src/3rd/pybind11/03.安装说明.md:75
msgid "3.2 通过PyPI来集成"
msgstr ""

#: ./src/3rd/pybind11/03.安装说明.md:77
msgid "你可以使用pip，通过PyPI来下载Pybind11的Python包，里面包含了源码已经CMake文件。像这样："
msgstr ""

#: ./src/3rd/pybind11/03.安装说明.md:83
msgid "这样pybind11将以标准的Python包的形式提供。如果你想在root环境下直接使用pybind11，可以这样做："
msgstr ""

#: ./src/3rd/pybind11/03.安装说明.md:86
msgid "\"pybind11[global]\""
msgstr ""

#: ./src/3rd/pybind11/03.安装说明.md:89
msgid ""
"如果你使用系统自带的Python来安装，我们推荐在root环境下安装。这样会在`/usr/local/include/pybind11` 和 "
"`/usr/local/share/cmake/pybind11`添加文件，除非你想这样。还是推荐你只在虚拟环境或你的`pyproject.toml`中使用。"
msgstr ""

#: ./src/3rd/pybind11/03.安装说明.md:91
msgid "3.3 通过conda-forge集成"
msgstr ""

#: ./src/3rd/pybind11/03.安装说明.md:93
msgid ""
"You can use pybind11 with conda packaging via "
"[conda-forge](https://github.com/conda-forge/pybind11-feedstock):"
msgstr ""

#: ./src/3rd/pybind11/03.安装说明.md:99
msgid "3.4 通过vcpkg集成"
msgstr ""

#: ./src/3rd/pybind11/03.安装说明.md:101
msgid ""
"你可以通过Microsoft "
"[vcpkg](https://github.com/Microsoft/vcpkg/)依赖管理工具来下载和安装pybind11："
msgstr ""

#: ./src/3rd/pybind11/03.安装说明.md:103
msgid ""
"```\n"
"git clone https://github.com/Microsoft/vcpkg.git\n"
"cd vcpkg\n"
"./bootstrap-vcpkg.sh\n"
"./vcpkg integrate install\n"
"vcpkg install pybind11\n"
"```"
msgstr ""

#: ./src/3rd/pybind11/03.安装说明.md:111
msgid "3.5 通过brew全局安装"
msgstr ""

#: ./src/3rd/pybind11/03.安装说明.md:113
msgid "brew包管理（Homebrew on macOS, or Linuxbrew on Linux）有pybind11包。这样安装："
msgstr ""

#: ./src/3rd/pybind11/03.安装说明.md:119
msgid "3.6 其他方法"
msgstr ""

#: ./src/3rd/pybind11/03.安装说明.md:121
msgid ""
"Other locations you can find pybind11 are [listed "
"here](https://repology.org/project/python:pybind11/versions); these are "
"maintained by various packagers and the community."
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:58
msgid "4. 首次尝试（First steps）"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:60
msgid "本章将演示pybind11的基本特性。在开始前，请确保正确配置了编译pybind11测试用例的开发环境。"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:62
msgid "4.1 编译测试用例"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:64
msgid "Linux/macOS"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:66
msgid ""
"在Linux上，你需要安装python-dev或python3-dev包和cmake。在macOS上，系统自带了所需的python版本，还需要安装cmake。"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:68
msgid "在安装好依赖项之后，运行下面的脚本："
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:76
msgid "脚本的最后一行将编译并运行测试用例。"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:78
msgid "Windows"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:80
msgid "在Windows上，需要支持C++11的Visual Studio版本（15及其以上）。"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:82
msgid ""
"Note：在Visual Studio 2017(MSVC "
"14.1)上使用C++17时，pybind11需要添加标识`/permissive-`来让编译器强制标准一致。在Visual Studio "
"2019上，不做强制要求，但同样建议添加。"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:84
msgid "使用以下命令编译和运行测试用例："
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:92
msgid "命令将在命令行创建Visual Studio工程，编译并运行项目。"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:93
msgid ""
"Note：如果测试失败了，请确保Python程序和测试用例是由同一类型处理器（如i386或x86_64）编译的。你可以指定x86_64为目标架构来生成vs工程，命令像这样`cmake "
"-A x64 ..`。"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:95
msgid "4.2 头文件和命名空间约定"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:97
msgid "为简洁起见，所有代码示例都假定存在以下两行："
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:99 ./src/3rd/pybind11/04.首次尝试.md:116
#: ./src/3rd/pybind11/05.面对对象编程.md:77
#: ./src/3rd/pybind11/12.Python的C++接口.md:451
#: ./src/3rd/pybind11/pybind11_demo.md:76
#: ./src/3rd/pybind11/pybind11_demo.md:186
msgid "<pybind11/pybind11.h>"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:103
msgid "某些功能可能需要其他头文件，但会根据需要指定。"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:105
msgid "4.3 为简单函数创建绑定"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:107
msgid "我们将从绑定一个简单的加法函数来演示pybind11的使用。"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:114
msgid "简单起见，我们将加法函数和绑定代码都放到`example.cpp`文件中，内容如下："
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:123 ./src/3rd/pybind11/pybind11_demo.md:83
msgid "\"pybind11 example plugin\""
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:123 ./src/3rd/pybind11/pybind11_demo.md:83
msgid "// optional module docstring\n"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:124 ./src/3rd/pybind11/04.首次尝试.md:153
#: ./src/3rd/pybind11/04.首次尝试.md:202
#: ./src/3rd/pybind11/13.内嵌解释器.md:169
#: ./src/3rd/pybind11/13.内嵌解释器.md:186
#: ./src/3rd/pybind11/13.内嵌解释器.md:195 ./src/3rd/pybind11/15.FAQ.md:141
#: ./src/3rd/pybind11/pybind11_demo.md:84
#: ./src/3rd/pybind11/pybind11_demo.md:93
#: ./src/3rd/pybind11/pybind11_demo.md:116
#: ./src/3rd/pybind11/pybind11_demo.md:136
#: ./src/3rd/pybind11/pybind11_demo.md:137
#: ./src/3rd/pybind11/pybind11_demo.md:142
#: ./src/3rd/pybind11/pybind11_demo.md:143
msgid "\"add\""
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:124 ./src/3rd/pybind11/04.首次尝试.md:153
#: ./src/3rd/pybind11/04.首次尝试.md:202 ./src/3rd/pybind11/pybind11_demo.md:84
#: ./src/3rd/pybind11/pybind11_demo.md:93
#: ./src/3rd/pybind11/pybind11_demo.md:116
msgid "\"A function which adds two numbers\""
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:128
msgid ""
"`PYBIND11_MODULE`会创建一个函数，它在Python中使用`import`语句时被调用。宏的第一个参数是模块名（example），不使用引号包住；第二个参数是类型为`py::module_`的变量（m），它是创建绑定的主要接口。`module_::def()`方法，则会生成add函数的Python绑定代码。"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:130
msgid ""
"Note：我们只需要少量的代码就可以将函数暴露给Python，函数入参和返回值相关的细节都由模板元编程自动推断。这种方式和语法是借用Boost.Python的，尽管底层实现完全不同。"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:132
msgid "pybind11是一个head-only库，它不需要链接任何库，也没有魔法般的中间转换步骤。在Linux上，示例可以使用下面的命令进行编译："
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:137
msgid ""
"Note：如果你使用子模块的方式包含pybind11代码，这里需要使用`$(python3-config --includes) "
"-Iextern/pybind11/include`代替`$(python3 -m pybind11 --includes)`。原因在后续章节会解释。"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:139
msgid "如果需要更多有关于Linux和MacOS上所需编译标志的详细信息，请参阅手动构建章节。有关完整的跨平台编译说明，请参阅构建系统章节。"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:141
msgid ""
"编译上面的C++代码后，我们会得到一个二进制模块文件，直接使用`import`导入模块到Python中。假设编译好的模块位于当前目录下，Python交互示例代码如下："
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:149
msgid "4.4 关键字参数"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:151
msgid "这里，我们对上面的C++代码做一点改造，就可以通知Python关于参数的名称（如本例中的“i”和“j”）。"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:154 ./src/3rd/pybind11/04.首次尝试.md:182
#: ./src/3rd/pybind11/04.首次尝试.md:185 ./src/3rd/pybind11/04.首次尝试.md:203
#: ./src/3rd/pybind11/04.首次尝试.md:222 ./src/3rd/pybind11/04.首次尝试.md:224
#: ./src/3rd/pybind11/pybind11_demo.md:94
#: ./src/3rd/pybind11/pybind11_demo.md:100
#: ./src/3rd/pybind11/pybind11_demo.md:103
#: ./src/3rd/pybind11/pybind11_demo.md:117
#: ./src/3rd/pybind11/pybind11_demo.md:123
#: ./src/3rd/pybind11/pybind11_demo.md:125
msgid "\"i\""
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:154 ./src/3rd/pybind11/04.首次尝试.md:182
#: ./src/3rd/pybind11/04.首次尝试.md:185 ./src/3rd/pybind11/04.首次尝试.md:203
#: ./src/3rd/pybind11/04.首次尝试.md:222 ./src/3rd/pybind11/04.首次尝试.md:224
#: ./src/3rd/pybind11/pybind11_demo.md:94
#: ./src/3rd/pybind11/pybind11_demo.md:100
#: ./src/3rd/pybind11/pybind11_demo.md:103
#: ./src/3rd/pybind11/pybind11_demo.md:117
#: ./src/3rd/pybind11/pybind11_demo.md:123
#: ./src/3rd/pybind11/pybind11_demo.md:125
msgid "\"j\""
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:157
msgid ""
"arg是可用于将元数据传递到module::def()的几个特殊标记类之一。使用上面修改后的代码，我们可以在调用函数时使用关键字参数，以增加代码可读性，特别是对那些带有多个参数的函数。"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:161
#: ./src/3rd/pybind11/pybind11_demo.md:109
msgid "#3L\n"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:164
msgid "关键字名称也会在文档的函数签名中显示："
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:178
msgid "还可以使用更加简短的方式给参数命名："
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:181 ./src/3rd/pybind11/04.首次尝试.md:221
#: ./src/3rd/pybind11/pybind11_demo.md:99
#: ./src/3rd/pybind11/pybind11_demo.md:122
msgid "// regular notation\n"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:182 ./src/3rd/pybind11/04.首次尝试.md:222
#: ./src/3rd/pybind11/pybind11_demo.md:100
#: ./src/3rd/pybind11/pybind11_demo.md:123
msgid "\"add1\""
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:182 ./src/3rd/pybind11/04.首次尝试.md:222
#: ./src/3rd/pybind11/pybind11_demo.md:100
#: ./src/3rd/pybind11/pybind11_demo.md:123
msgid "// shorthand\n"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:185 ./src/3rd/pybind11/04.首次尝试.md:224
#: ./src/3rd/pybind11/pybind11_demo.md:103
#: ./src/3rd/pybind11/pybind11_demo.md:125
msgid "\"add2\""
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:188
msgid ""
"后缀`_a`会生成一个等价于`arg`方法的字面量。使用这个后缀时，需要调用`using namespace "
"pybind11::literals`来声明后缀所在的命名空间。这样除了`literals`外，不会从pybind11命名空间引入其他不必要的东西。"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:190
msgid "4.5 默认参数"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:192
msgid "现在我们需要绑定一个带默认参数的函数："
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:199
msgid "pybind11不能自动地提取默认参数，因为它不属于函数类型信息的一部分。我们需要借助`arg`来实现这一功能："
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:206
msgid "默认值同样也会在文档中展示："
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:219
#: ./src/3rd/pybind11/pybind11_demo.md:120
msgid "更简短的声明方式："
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:227
msgid "4.6 导出变量"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:229
msgid ""
"我们可以使用`attr`函数来注册需要导出到Python模块中的C++变量。内建类型和常规对象（后面会细讲）会在指定attriutes时自动转换，也可以使用`py::cast`来显式转换。"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:233
#: ./src/3rd/pybind11/pybind11_demo.md:154
msgid "\"the_answer\""
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:234
#: ./src/3rd/pybind11/13.内嵌解释器.md:120
#: ./src/3rd/pybind11/13.内嵌解释器.md:138
#: ./src/3rd/pybind11/pybind11_demo.md:155
msgid "\"World\""
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:235
#: ./src/3rd/pybind11/pybind11_demo.md:156
msgid "\"what\""
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:244
#: ./src/3rd/pybind11/pybind11_demo.md:165
msgid "'World'"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:248
msgid "4.7 支持的数据类型"
msgstr ""

#: ./src/3rd/pybind11/04.首次尝试.md:250
msgid ""
"原生支持大量数据类型，完美适用于函数参数，参数值通常直接返回或者经过py::cast处理再返回。有关完整概述，请参阅类型转换部分。(A large "
"number of data types are supported out of the box and can be used seamlessly "
"as functions arguments, return values or with py::cast in general. For a "
"full overview, see the Type conversions section.)"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:58
msgid "5. 面对对象编程"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:60
msgid "5.1 创建一个自定义类的绑定"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:62
msgid "让我们来看一个更加复杂的例子：绑定一个C++自定义数据结构`Pet`。定义如下："
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:74
#: ./src/3rd/pybind11/05.面对对象编程.md:408
#: ./src/3rd/pybind11/pybind11_demo.md:183
msgid "绑定代码如下所示："
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:81
#: ./src/3rd/pybind11/05.面对对象编程.md:119
#: ./src/3rd/pybind11/05.面对对象编程.md:142
#: ./src/3rd/pybind11/05.面对对象编程.md:173
#: ./src/3rd/pybind11/05.面对对象编程.md:205
#: ./src/3rd/pybind11/05.面对对象编程.md:240
#: ./src/3rd/pybind11/05.面对对象编程.md:327
#: ./src/3rd/pybind11/05.面对对象编程.md:355
#: ./src/3rd/pybind11/05.面对对象编程.md:379
#: ./src/3rd/pybind11/05.面对对象编程.md:410 ./src/3rd/pybind11/08.类.md:675
#: ./src/3rd/pybind11/08.类.md:725 ./src/3rd/pybind11/14.杂项.md:135
#: ./src/3rd/pybind11/14.杂项.md:147 ./src/3rd/pybind11/pybind11_demo.md:190
#: ./src/3rd/pybind11/pybind11_demo.md:227
#: ./src/3rd/pybind11/pybind11_demo.md:258
#: ./src/3rd/pybind11/pybind11_demo.md:290
#: ./src/3rd/pybind11/pybind11_demo.md:323
#: ./src/3rd/pybind11/pybind11_demo.md:329
#: ./src/3rd/pybind11/pybind11_demo.md:564
msgid "\"Pet\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:83
#: ./src/3rd/pybind11/05.面对对象编程.md:121
#: ./src/3rd/pybind11/pybind11_demo.md:192
msgid "\"setName\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:84
#: ./src/3rd/pybind11/05.面对对象编程.md:122
#: ./src/3rd/pybind11/pybind11_demo.md:193
msgid "\"getName\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:88
msgid ""
"`class_`会创建C++ class或 "
"struct的绑定。`init()`方法使用类构造函数的参数类型作为模板参数，并包装相应的构造函数（详见[自定义构造函数](https://pybind11.readthedocs.io/en/stable/advanced/classes.html#custom-constructors)）。Python使用示例如下；"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:92
#: ./src/3rd/pybind11/05.面对对象编程.md:150
#: ./src/3rd/pybind11/05.面对对象编程.md:188
#: ./src/3rd/pybind11/05.面对对象编程.md:257
#: ./src/3rd/pybind11/05.面对对象编程.md:267
#: ./src/3rd/pybind11/pybind11_demo.md:209
#: ./src/3rd/pybind11/pybind11_demo.md:235
#: ./src/3rd/pybind11/pybind11_demo.md:273
#: ./src/3rd/pybind11/pybind11_demo.md:581
#: ./src/3rd/pybind11/pybind11_demo.md:591
msgid "\"Molly\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:96
#: ./src/3rd/pybind11/05.面对对象编程.md:132
#: ./src/3rd/pybind11/05.面对对象编程.md:152
#: ./src/3rd/pybind11/05.面对对象编程.md:259
#: ./src/3rd/pybind11/pybind11_demo.md:211
#: ./src/3rd/pybind11/pybind11_demo.md:213
#: ./src/3rd/pybind11/pybind11_demo.md:237
#: ./src/3rd/pybind11/pybind11_demo.md:583
msgid "'Molly'"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:97
#: ./src/3rd/pybind11/05.面对对象编程.md:153
#: ./src/3rd/pybind11/pybind11_demo.md:214
#: ./src/3rd/pybind11/pybind11_demo.md:238
msgid "\"Charly\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:99
#: ./src/3rd/pybind11/05.面对对象编程.md:155
#: ./src/3rd/pybind11/pybind11_demo.md:216
#: ./src/3rd/pybind11/pybind11_demo.md:240
msgid "'Charly'"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:102
msgid "**See also**：静态成员函数需要使用`class_::def_static`来绑定。"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:104
msgid "5.2 关键字参数和默认参数"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:106
msgid "可以使用第4章讨论的语法来指定关键字和默认参数，详见第4章相关章节。"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:108
msgid "5.3 绑定匿名函数"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:110
msgid "使用`print(p)`打印对象信息时，上面的例子会得到一些基本无用的信息。"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:116
msgid ""
"我们可以绑定一个工具函数到`__repr__`方法，来返回可读性好的摘要信息。在不改变Pet类的基础上，使用一个匿名函数来完成这个功能是一个不错的选择。"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:123 ./src/3rd/pybind11/08.类.md:551
#: ./src/3rd/pybind11/pybind11_demo.md:194
#: ./src/3rd/pybind11/pybind11_demo.md:933
msgid "\"__repr__\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:125
#: ./src/3rd/pybind11/pybind11_demo.md:196
msgid "\"<example.Pet named '\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:125
#: ./src/3rd/pybind11/pybind11_demo.md:196
msgid "\"'>\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:129
msgid "通过上面的修改，Python中的输出如下："
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:135
msgid "pybind11支持无状态和有状态的lambda闭包，即lambda表达式的`[]`是否带捕获参数。"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:137
msgid "5.4 成员变量"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:139
#: ./src/3rd/pybind11/pybind11_demo.md:223
msgid ""
"使用`class_::def_readwrite`方法可以导出公有成员变量，使用`class_::def_readonly`方法则可以导出只读成员。"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:144
#: ./src/3rd/pybind11/05.面对对象编程.md:175
#: ./src/3rd/pybind11/05.面对对象编程.md:207
#: ./src/3rd/pybind11/05.面对对象编程.md:242
#: ./src/3rd/pybind11/05.面对对象编程.md:413 ./src/3rd/pybind11/08.类.md:677
#: ./src/3rd/pybind11/13.内嵌解释器.md:120
#: ./src/3rd/pybind11/13.内嵌解释器.md:138 ./src/3rd/pybind11/14.杂项.md:137
#: ./src/3rd/pybind11/pybind11_demo.md:229
#: ./src/3rd/pybind11/pybind11_demo.md:260
#: ./src/3rd/pybind11/pybind11_demo.md:292
#: ./src/3rd/pybind11/pybind11_demo.md:566
msgid "\"name\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:145
#: ./src/3rd/pybind11/05.面对对象编程.md:176
#: ./src/3rd/pybind11/pybind11_demo.md:230
#: ./src/3rd/pybind11/pybind11_demo.md:261
msgid "// ... remainder ...\n"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:148 ./src/3rd/pybind11/08.类.md:611
#: ./src/3rd/pybind11/pybind11_demo.md:233
msgid "Python中使用示例如下："
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:158
#: ./src/3rd/pybind11/pybind11_demo.md:243
msgid "假设`Pet::name`是一个私有成员变量，向外提供setter和getters方法。"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:171
#: ./src/3rd/pybind11/pybind11_demo.md:256
msgid ""
"可以使用`class_::def_property()`(只读成员使用`class_::def_property_readonly()`)来定义并私有成员，并生成相应的setter和geter方法："
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:179
#: ./src/3rd/pybind11/pybind11_demo.md:264
msgid "只写属性通过将read函数定义为nullptr来实现。"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:181
msgid ""
"**see also**: 相似的方法`class_::def_readwrite_static()`, "
"`class_::def_readonly_static()` `class_::def_property_static()`, "
"`class_::def_property_readonly_static()`用于绑定静态变量和属性。"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:183
msgid "5.5 动态属性"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:185
#: ./src/3rd/pybind11/pybind11_demo.md:270
msgid "原生的Pyhton类可以动态地获取新属性："
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:191
#: ./src/3rd/pybind11/pybind11_demo.md:276
msgid "\"Charly\"  # overwrite existing\n"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:192
#: ./src/3rd/pybind11/pybind11_demo.md:277
msgid "# dynamically add a new attribute\n"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:195
#: ./src/3rd/pybind11/pybind11_demo.md:280
msgid ""
"默认情况下，从C++导出的类不支持动态属性，其可写属性必须是通过`class_::def_readwrite`或`class_::def_property`定义的。试图设置其他属性将产生错误："
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:198
#: ./src/3rd/pybind11/pybind11_demo.md:283
msgid "\"Charly\"  # OK, attribute defined in C++\n"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:199
#: ./src/3rd/pybind11/pybind11_demo.md:284
msgid "# fail\n"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:200
#: ./src/3rd/pybind11/05.面对对象编程.md:275
#: ./src/3rd/pybind11/pybind11_demo.md:285
#: ./src/3rd/pybind11/pybind11_demo.md:599
msgid "'Pet'"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:200
#: ./src/3rd/pybind11/05.面对对象编程.md:217
#: ./src/3rd/pybind11/pybind11_demo.md:285
#: ./src/3rd/pybind11/pybind11_demo.md:302
msgid "'age'"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:203
#: ./src/3rd/pybind11/pybind11_demo.md:288
msgid "要让C++类也支持动态属性，我们需要在`py::class_`的构造函数添加`py::dynamic_attr`标识："
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:210
#: ./src/3rd/pybind11/pybind11_demo.md:295
msgid "这样，之前报错的代码就能够正常运行了。"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:214
#: ./src/3rd/pybind11/pybind11_demo.md:299
msgid "\"Charly\"  # OK, overwrite value in C++\n"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:215
#: ./src/3rd/pybind11/pybind11_demo.md:300
msgid "# OK, dynamically add a new attribute\n"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:216
#: ./src/3rd/pybind11/pybind11_demo.md:301
msgid "# just like a native Python class\n"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:220
#: ./src/3rd/pybind11/pybind11_demo.md:305
msgid ""
"需要提醒一下，支持动态属性会带来小小的运行时开销。不仅仅因为增加了额外的`__dict__`属性，还因为处理循环引用时需要花费更多的垃圾收集跟踪花销。但是不必担心这个问题，因为原生Python类也有同样的开销。默认情况下，pybind11导出的类比原生Python类效率更高，使能动态属性也只是让它们处于同等水平而已。"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:222
msgid "5.6 继承与向下转型"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:224
#: ./src/3rd/pybind11/pybind11_demo.md:548
msgid "现在有两个具有继承关系的类："
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:233
#: ./src/3rd/pybind11/05.面对对象编程.md:286 ./src/3rd/pybind11/07.函数.md:311
#: ./src/3rd/pybind11/08.类.md:221 ./src/3rd/pybind11/08.类.md:858
#: ./src/3rd/pybind11/pybind11_demo.md:557
#: ./src/3rd/pybind11/pybind11_demo.md:610
#: ./src/3rd/pybind11/pybind11_demo.md:774
msgid "\"woof!\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:237
#: ./src/3rd/pybind11/pybind11_demo.md:561
msgid ""
"pybind11提供了两种方法来指明继承关系：1）将C++基类作为派生类`class_`的模板参数；2）将基类名作为`class_`的参数绑定到派生类。两种方法是等效的。"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:243
#: ./src/3rd/pybind11/pybind11_demo.md:567
msgid "// Method 1: template parameter:\n"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:245
#: ./src/3rd/pybind11/pybind11_demo.md:569
msgid "/* <- specify C++ parent type */"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:245
#: ./src/3rd/pybind11/05.面对对象编程.md:250
#: ./src/3rd/pybind11/05.面对对象编程.md:418 ./src/3rd/pybind11/07.函数.md:308
#: ./src/3rd/pybind11/08.类.md:99 ./src/3rd/pybind11/08.类.md:149
#: ./src/3rd/pybind11/08.类.md:282 ./src/3rd/pybind11/14.杂项.md:113
#: ./src/3rd/pybind11/14.杂项.md:139 ./src/3rd/pybind11/14.杂项.md:149
#: ./src/3rd/pybind11/14.杂项.md:159 ./src/3rd/pybind11/pybind11_demo.md:569
#: ./src/3rd/pybind11/pybind11_demo.md:574
#: ./src/3rd/pybind11/pybind11_demo.md:662
#: ./src/3rd/pybind11/pybind11_demo.md:711
#: ./src/3rd/pybind11/pybind11_demo.md:835
#: ./src/3rd/pybind11/pybind11_demo.md:1282
msgid "\"Dog\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:247
#: ./src/3rd/pybind11/05.面对对象编程.md:252
#: ./src/3rd/pybind11/05.面对对象编程.md:293 ./src/3rd/pybind11/07.函数.md:310
#: ./src/3rd/pybind11/14.杂项.md:141 ./src/3rd/pybind11/14.杂项.md:151
#: ./src/3rd/pybind11/14.杂项.md:161 ./src/3rd/pybind11/pybind11_demo.md:571
#: ./src/3rd/pybind11/pybind11_demo.md:576
#: ./src/3rd/pybind11/pybind11_demo.md:617
msgid "\"bark\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:248
#: ./src/3rd/pybind11/pybind11_demo.md:572
msgid "// Method 2: pass parent class_ object:\n"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:250
#: ./src/3rd/pybind11/pybind11_demo.md:574
msgid "/* <- specify Python parent type */"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:255
#: ./src/3rd/pybind11/pybind11_demo.md:579
msgid "指明继承关系后，派生类实例将获得两者的字段和方法："
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:261
#: ./src/3rd/pybind11/05.面对对象编程.md:304 ./src/3rd/pybind11/07.函数.md:323
#: ./src/3rd/pybind11/pybind11_demo.md:585
#: ./src/3rd/pybind11/pybind11_demo.md:628
msgid "'woof!'"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:264
#: ./src/3rd/pybind11/pybind11_demo.md:588
msgid "上面的例子是一个常规非多态的继承关系，表现在Python就是："
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:266
#: ./src/3rd/pybind11/pybind11_demo.md:590
msgid "// 返回一个指向派生类的基类指针\n"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:267
#: ./src/3rd/pybind11/pybind11_demo.md:591
msgid "\"pet_store\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:272
#: ./src/3rd/pybind11/pybind11_demo.md:596
msgid "# `Dog` instance behind `Pet` pointer\n"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:273
#: ./src/3rd/pybind11/pybind11_demo.md:597
msgid "# no pointer downcasting for regular non-polymorphic types\n"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:275
#: ./src/3rd/pybind11/pybind11_demo.md:599
msgid "'bark'"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:278
#: ./src/3rd/pybind11/pybind11_demo.md:602
msgid ""
"`pet_store`函数返回了一个Dog实例，但由于基类并非多态类型，Python只识别到了Pet。在C++中，一个类至少有一个虚函数才会被视为多态类型。pybind11会自动识别这种多态机制。"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:288
#: ./src/3rd/pybind11/pybind11_demo.md:612
msgid "// Same binding code\n"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:290
#: ./src/3rd/pybind11/pybind11_demo.md:614
msgid "\"PolymorphicPet\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:291
#: ./src/3rd/pybind11/pybind11_demo.md:615
msgid "\"PolymorphicDog\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:294
#: ./src/3rd/pybind11/pybind11_demo.md:618
msgid "// Again, return a base pointer to a derived instance\n"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:296
#: ./src/3rd/pybind11/pybind11_demo.md:620
msgid "\"pet_store2\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:302
#: ./src/3rd/pybind11/pybind11_demo.md:626
msgid "# automatically downcast\n"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:307
#: ./src/3rd/pybind11/pybind11_demo.md:631
msgid ""
"pybind11会自动地将一个指向多态基类的指针，向下转型为实际的派生类类型。这和C++常见的情况不同，我们不仅可以访问基类的虚函数，还能获取到通过基类看不到的，具体的派生类的方法和属性。"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:309
msgid "5.7 重载方法"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:311
msgid "重载方法即拥有相同的函数名，但入参不一样的函数："
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:324
msgid ""
"我们在绑定`Pet::set`时会报错，因为编译器并不知道用户想选择哪个重载方法。我们需要添加具体的函数指针来消除歧义。绑定多个函数到同一个Python名称，将会自动创建函数重载链。Python将会依次匹配，找到最合适的重载函数。"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:329
#: ./src/3rd/pybind11/05.面对对象编程.md:330
#: ./src/3rd/pybind11/05.面对对象编程.md:356
#: ./src/3rd/pybind11/05.面对对象编程.md:357
#: ./src/3rd/pybind11/05.面对对象编程.md:380
#: ./src/3rd/pybind11/05.面对对象编程.md:381
#: ./src/3rd/pybind11/pybind11_demo.md:325
#: ./src/3rd/pybind11/pybind11_demo.md:326
#: ./src/3rd/pybind11/pybind11_demo.md:330
#: ./src/3rd/pybind11/pybind11_demo.md:331
msgid "\"set\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:329
#: ./src/3rd/pybind11/05.面对对象编程.md:356
#: ./src/3rd/pybind11/05.面对对象编程.md:380
#: ./src/3rd/pybind11/pybind11_demo.md:325
#: ./src/3rd/pybind11/pybind11_demo.md:330
msgid "\"Set the pet's age\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:330
#: ./src/3rd/pybind11/05.面对对象编程.md:357
#: ./src/3rd/pybind11/05.面对对象编程.md:381
#: ./src/3rd/pybind11/pybind11_demo.md:326
#: ./src/3rd/pybind11/pybind11_demo.md:331
msgid "\"Set the pet's name\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:333
msgid "在函数的文档描述中，我们可以看见重载的函数签名："
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:346
msgid "'s age\n"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:350
msgid "'s name\n"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:353
#: ./src/3rd/pybind11/pybind11_demo.md:140
msgid "如果你的编译器支持C++14，也可以使用下面的语法来转换重载函数："
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:360
#: ./src/3rd/pybind11/pybind11_demo.md:146
msgid ""
"这里，`py::overload_cast`仅需指定函数类型，不用给出返回值类型，以避免原语法带来的不必要的干扰(`void "
"(Pet::*)`)。如果是基于const的重载，需要使用`py::const`标识。"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:368
msgid "\"Widget\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:369
msgid "\"foo_mutable\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:370
msgid "\"foo_const\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:373
msgid ""
"如果你想在仅支持c++11的编译器上使用`py::overload_cast`语法，可以使用`py::detail::overload_cast_impl`来代替："
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:384
msgid ""
"Note: 如果想定义多个重载的构造函数，使用`.def(py::init<...>())`语法依次定义就好，指定关键字和默认参数的机制也还是生效的。"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:386
msgid "5.8 枚举和内部类型"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:388
msgid "现在有一个含有枚举和内部类型的类："
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:414
msgid "\"type\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:415
msgid "\"attr\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:417
#: ./src/3rd/pybind11/05.面对对象编程.md:458
msgid "\"Kind\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:419 ./src/3rd/pybind11/07.函数.md:309
msgid "\"Cat\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:422
msgid "\"Attributes\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:424
msgid "\"age\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:427
msgid ""
"为确保嵌套类型`Kind`和`Attributes`在`Pet`的作用域中创建，我们必须向`enum_`和`class_`的构造函数提供`Pet` "
"`class_`实例。`enum_::export_values()`用来导出枚举项到父作用域，C++11的强枚举类型需要跳过这点。"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:430
#: ./src/3rd/pybind11/05.面对对象编程.md:446
msgid "\"Lucy\""
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:437
msgid "枚举类型的枚举项会被导出到类`__members__`属性中："
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:440
msgid "'Dog'"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:440
#: ./src/3rd/pybind11/05.面对对象编程.md:452
msgid "'Cat'"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:443
msgid "`name`属性可以返回枚举值的名称的unicode字符串，`str(enum)`也可以做到，但两者的实现目标不同。下面的例子展示了两者的差异："
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:450
msgid "'Pet.Cat'"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:456
msgid ""
"Note: "
"当我们给`enum_`的构造函数增加`py::arithmetic()`标识时，pybind11将创建一个支持基本算术运算和位运算（如比较、或、异或、取反等）的枚举类型。"
msgstr ""

#: ./src/3rd/pybind11/05.面对对象编程.md:461
msgid "默认情况下，省略这些可以节省内存空间。"
msgstr ""

#: ./src/3rd/pybind11/06.构建系统.md:58
msgid "6. 构建系统"
msgstr ""

#: ./src/3rd/pybind11/06.构建系统.md:60
msgid "后续再翻译。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:58
msgid "7. 函数"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:60
msgid "在开始本节前，请确保你已经熟悉了第4章和第5章讲述的函数和类绑定的基本方法。下面我们将继续讲述普通函数、成员函数、以及Python方法的知识点。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:62
msgid "7.1 返回值策略"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:64 ./src/3rd/pybind11/pybind11_demo.md:383
msgid ""
"Python和C++在管理内存和对象生命周期管理上存在本质的区别。这导致我们在创建返回no-trivial类型的函数绑定时会出问题。仅通过类型信息，我们无法明确是Python侧需要接管返回值并负责释放资源，还是应该由C++侧来处理。因此，pybind11提供了一些返回值策略来确定由哪方管理资源。这些策略通过`model::def()`和`class_def()`来指定，默认策略为`return_value_policy::automatic`。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:66 ./src/3rd/pybind11/pybind11_demo.md:385
msgid "返回值策略难以捉摸，正确地选择它们则显得尤为重要。下面我们通过一个简单的例子来阐释选择错误的情形："
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:68 ./src/3rd/pybind11/pybind11_demo.md:387
msgid "/* Function declaration */"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:69 ./src/3rd/pybind11/pybind11_demo.md:388
msgid "/* (pointer to a static data structure) */"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:71 ./src/3rd/pybind11/pybind11_demo.md:390
msgid "/* Binding code */"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:73 ./src/3rd/pybind11/07.函数.md:82
#: ./src/3rd/pybind11/pybind11_demo.md:392
#: ./src/3rd/pybind11/pybind11_demo.md:401
msgid "\"get_data\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:73 ./src/3rd/pybind11/pybind11_demo.md:392
msgid "// <-- KABOOM, will cause crash when called from Python\n"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:76 ./src/3rd/pybind11/pybind11_demo.md:395
msgid ""
"当Python侧调用`get_data()`方法时，返回值（原生C++类型）必须被转换为合适的Python类型。在这个例子中，默认的返回值策略（`return_value_policy::automatic`）使得pybind11获取到了静态变量`_data`的所有权。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:78 ./src/3rd/pybind11/pybind11_demo.md:397
msgid ""
"当Python垃圾收集器最终删除`_data`的Python封装时，pybind11将尝试删除C++实例（通过operator "
"delete()）。这时，这个程序将以某种隐蔽的错误并涉及静默数据破坏的方式崩溃。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:80 ./src/3rd/pybind11/pybind11_demo.md:399
msgid ""
"对于上面的例子，我们应该指定返回值策略为`return_value_policy::reference`，这样全局变量的实例仅仅被引用，而不涉及到所有权的转移："
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:85 ./src/3rd/pybind11/pybind11_demo.md:404
msgid ""
"另一方面，引用策略在多数其他场合并不是正确的策略，忽略所有权的归属可能导致资源泄漏。作为一个使用pybind11的开发者，熟悉不同的返回值策略及其适用场合尤为重要。下面的表格将提供所有策略的概览："
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:87 ./src/3rd/pybind11/pybind11_demo.md:406
msgid "返回值策略"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:87 ./src/3rd/pybind11/pybind11_demo.md:406
msgid "描述"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:89 ./src/3rd/pybind11/pybind11_demo.md:408
msgid "`return_value_policy::take_ownership`"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:89 ./src/3rd/pybind11/pybind11_demo.md:408
msgid "引用现有对象（不创建一个新对象），并获取所有权。在引用计数为0时，Pyhton将调用析构函数和delete操作销毁对象。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:90 ./src/3rd/pybind11/pybind11_demo.md:409
msgid "`return_value_policy::copy`"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:90 ./src/3rd/pybind11/pybind11_demo.md:409
msgid "拷贝返回值，这样Python将拥有拷贝的对象。该策略相对来说比较安全，因为两个实例的生命周期是分离的。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:91 ./src/3rd/pybind11/pybind11_demo.md:410
msgid "`return_value_policy::move`"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:91 ./src/3rd/pybind11/pybind11_demo.md:410
msgid "使用`std::move`来移动返回值的内容到新实例，新实例的所有权在Python。该策略相对来说比较安全，因为两个实例的生命周期是分离的。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:92 ./src/3rd/pybind11/pybind11_demo.md:411
msgid "`return_value_policy::reference`"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:92 ./src/3rd/pybind11/pybind11_demo.md:411
msgid ""
"引用现有对象，但不拥有所有权。C++侧负责该对象的生命周期管理，并在对象不再被使用时负责析构它。注意：当Python侧还在使用引用的对象时，C++侧删除对象将导致未定义行为。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:93 ./src/3rd/pybind11/pybind11_demo.md:412
msgid "`return_value_policy::reference_internal`"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:93 ./src/3rd/pybind11/pybind11_demo.md:412
msgid ""
"返回值的生命周期与父对象的生命周期相绑定，即被调用函数或属性的`this`或`self`对象。这种策略与reference策略类似，但附加了`keep_alive<0, "
"1>`调用策略保证返回值还被Python引用时，其父对象就不会被垃圾回收掉。这是由`def_property`、`def_readwrite`创建的属性getter方法的默认返回值策略。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:94 ./src/3rd/pybind11/pybind11_demo.md:413
msgid "`return_value_policy::automatic`"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:94 ./src/3rd/pybind11/pybind11_demo.md:413
msgid ""
"当返回值是指针时，该策略使用`return_value_policy::take_ownership`。反之对左值和右值引用使用`return_value_policy::copy`。请参阅上面的描述，了解所有这些不同的策略的作用。这是`py::class_`封装类型的默认策略。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:95 ./src/3rd/pybind11/pybind11_demo.md:414
msgid "`return_value_policy::automatic_reference`"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:95 ./src/3rd/pybind11/pybind11_demo.md:414
msgid ""
"和上面一样，但是当返回值是指针时，使用`return_value_policy::reference`策略。这是在C++代码手动调用Python函数和使用`pybind11/stl.h`中的casters时的默认转换策略。你可能不需要显式地使用该策略。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:97 ./src/3rd/pybind11/pybind11_demo.md:416
msgid "返回值策略也可以应用于属性："
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:99 ./src/3rd/pybind11/07.函数.md:106
#: ./src/3rd/pybind11/07.函数.md:215 ./src/3rd/pybind11/07.函数.md:232
#: ./src/3rd/pybind11/07.函数.md:238 ./src/3rd/pybind11/08.类.md:445
#: ./src/3rd/pybind11/11.类型转换.md:461
#: ./src/3rd/pybind11/pybind11_demo.md:418
#: ./src/3rd/pybind11/pybind11_demo.md:425
#: ./src/3rd/pybind11/pybind11_demo.md:864
msgid "\"MyClass\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:100 ./src/3rd/pybind11/07.函数.md:107
#: ./src/3rd/pybind11/pybind11_demo.md:419
#: ./src/3rd/pybind11/pybind11_demo.md:426
msgid "\"data\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:104 ./src/3rd/pybind11/pybind11_demo.md:423
msgid ""
"在技术层面，上述代码会将策略同时应用于getter和setter函数，但是setter函数并不关心返回值策略，这样做仅仅出于语法简洁的考虑。或者，你可以通过`cpp_function`构造函数来传递目标参数："
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:113 ./src/3rd/pybind11/pybind11_demo.md:432
msgid ""
"**注意**：代码使用无效的返回值策略将导致未初始化内存或多次free数据结构，这将导致难以调试的、不确定的问题和段错误。因此，花点时间来理解上面表格的各个选项是值得的。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:115 ./src/3rd/pybind11/pybind11_demo.md:434
msgid "**提示**："
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:116 ./src/3rd/pybind11/pybind11_demo.md:435
msgid ""
"上述策略的另一个重点是，他们仅可以应用于pybind11还不知晓的实例，这时策略将澄清返回值的生命周期和所有权问题。当pybind11已经知晓参数（通过其在内存中的类型和地址来识别），它将返回已存在的Python对象封装，而不是创建一份拷贝。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:117 ./src/3rd/pybind11/pybind11_demo.md:436
msgid "下一节将讨论上面表格之外的调用策略，他涉及到返回值和函数参数的引用关系。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:118 ./src/3rd/pybind11/pybind11_demo.md:437
msgid ""
"可以考虑使用智能指针来代替复杂的调用策略和生命周期管理逻辑。智能指针会告诉你一个对象是否仍被C++或Python引用，这样就可以消除各种可能引发crash或未定义行为的矛盾。对于返回智能指针的函数，没必要指定返回值策略。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:120
msgid "7.2 附加的调用策略"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:122 ./src/3rd/pybind11/pybind11_demo.md:441
msgid "除了以上的返回值策略外，进一步指定调用策略可以表明参数间的依赖关系，确保函数调用的稳定性。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:124 ./src/3rd/pybind11/pybind11_demo.md:443
msgid "保活（keep alive）"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:126 ./src/3rd/pybind11/pybind11_demo.md:445
msgid ""
"当一个C++容器对象包含另一个C++对象时，我们需要使用该策略。`keep_alive<Nurse, "
"Patient>`表明至少在索引Nurse被回收前，索引Patient应该被保活。0表示返回值，1及以上表示参数索引。1表示隐含的参数this指针，而常规参数索引从2开始。当Nurse的值在运行前被检测到为None时，调用策略将什么都不做。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:128 ./src/3rd/pybind11/pybind11_demo.md:447
msgid ""
"当nurse不是一个pybind11注册类型时，实现依赖于创建对nurse对象弱引用的能力。如果nurse对象不是pybind11注册类型，也不支持弱引用，程序将会抛出异常。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:130 ./src/3rd/pybind11/pybind11_demo.md:449
msgid ""
"如果你使用一个错误的参数索引，程序将会抛出\"Could not cativate "
"keep_alive!\"警告的运行时异常。这时，你应该review你代码中使用的索引。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:132 ./src/3rd/pybind11/pybind11_demo.md:451
msgid "参见下面的例子：一个list append操作，将新添加元素的生命周期绑定到添加的容器对象上："
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:134 ./src/3rd/pybind11/pybind11_demo.md:453
msgid "\"List\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:134 ./src/3rd/pybind11/pybind11_demo.md:453
msgid "\"append\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:137 ./src/3rd/pybind11/pybind11_demo.md:456
msgid ""
"为了一致性，构造函数的实参索引也是相同的。索引1仍表示this指针，索引0表示返回值（构造函数的返回值被认为是void）。下面的示例将构造函数入参的生命周期绑定到被构造对象上。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:139 ./src/3rd/pybind11/pybind11_demo.md:458
msgid "\"Nurse\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:142 ./src/3rd/pybind11/pybind11_demo.md:461
msgid ""
"Note: "
"`keep_alive`与Boost.Python中的`with_custodian_and_ward`和`with_custodian_and_ward_postcall`相似。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:144 ./src/3rd/pybind11/pybind11_demo.md:463
msgid "Call guard"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:146 ./src/3rd/pybind11/pybind11_demo.md:465
msgid "`call_guard<T>`策略允许任意T类型的scope guard应用于整个函数调用。示例如下："
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:148 ./src/3rd/pybind11/07.函数.md:153
#: ./src/3rd/pybind11/07.函数.md:182 ./src/3rd/pybind11/08.类.md:508
#: ./src/3rd/pybind11/08.类.md:778 ./src/3rd/pybind11/08.类.md:795
#: ./src/3rd/pybind11/08.类.md:822 ./src/3rd/pybind11/15.FAQ.md:114
#: ./src/3rd/pybind11/pybind11_demo.md:467
#: ./src/3rd/pybind11/pybind11_demo.md:472
#: ./src/3rd/pybind11/pybind11_demo.md:997
#: ./src/3rd/pybind11/pybind11_demo.md:1014
#: ./src/3rd/pybind11/pybind11_demo.md:1041
msgid "\"foo\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:151 ./src/3rd/pybind11/pybind11_demo.md:470
msgid "上面的代码等价于："
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:155 ./src/3rd/pybind11/pybind11_demo.md:474
msgid "// forwarded arguments\n"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:159 ./src/3rd/pybind11/pybind11_demo.md:478
msgid "仅要求模板参数T是可构造的，如`gil_scoped_release`就是一个非常有用的类型。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:161 ./src/3rd/pybind11/pybind11_demo.md:480
msgid "`call_guard`支持同时制定多个模板参数，`call_guard<T1, T2, T3 ...>`。构造顺序是从左至右，析构顺序则相反。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:163 ./src/3rd/pybind11/pybind11_demo.md:482
msgid ""
"See also: "
"`test/test_call_policies.cpp`含有更丰富的示例来展示`keep_alive`和`call_guard`的用法。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:165
msgid "7.3 以Python对象作为参数"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:167
msgid ""
"pybind11通过简单的C++封装类，公开了绝大多数Python类型。这些封装类也可以在绑定代码宏作为函数参数使用，这样我们就可以在C++侧使用原生的python类型。举个遍历Python "
"dict的例子："
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:170
msgid "/* Easily interact with Python types */"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:172
msgid "\"key=\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:172 ./src/3rd/pybind11/08.类.md:530
#: ./src/3rd/pybind11/pybind11_demo.md:912
msgid "\", \""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:173
msgid "\"value=\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:175
msgid "// it can be exported as follow:\n"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:177
msgid "\"print_dict\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:180
msgid "在Python中使用如下："
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:182
msgid "\"bar\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:182
#: ./src/3rd/pybind11/12.Python的C++接口.md:146
#: ./src/3rd/pybind11/12.Python的C++接口.md:180
#: ./src/3rd/pybind11/12.Python的C++接口.md:187
#: ./src/3rd/pybind11/12.Python的C++接口.md:196
#: ./src/3rd/pybind11/12.Python的C++接口.md:200
#: ./src/3rd/pybind11/12.Python的C++接口.md:206
msgid "\"hello\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:187
msgid "7.4 接收`*args`和`**kwatgs`参数"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:189 ./src/3rd/pybind11/pybind11_demo.md:357
msgid "Python的函数可以接收任意数量的参数和关键字参数："
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:192 ./src/3rd/pybind11/pybind11_demo.md:360
msgid "# do something with args and kwargs\n"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:195 ./src/3rd/pybind11/pybind11_demo.md:363
msgid "我们也可以通过pybind11来创建这样的函数："
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:198 ./src/3rd/pybind11/pybind11_demo.md:366
msgid "/// .. do something with args\n"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:200 ./src/3rd/pybind11/pybind11_demo.md:368
msgid "/// .. do something with kwargs\n"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:202 ./src/3rd/pybind11/pybind11_demo.md:370
msgid "/// Binding code\n"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:204 ./src/3rd/pybind11/pybind11_demo.md:372
msgid "\"generic\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:207 ./src/3rd/pybind11/pybind11_demo.md:375
msgid "`py::args`继承自`py::tuple`，`py::kwargs`继承自`py::dict`。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:209
msgid "更多示例参考`test/test_kwargs_and_defualts.cpp`。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:211
msgid "7.5 再探默认参数"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:213
msgid "前面的章节已经讨论了默认参数的基本用法。关于实现有一个值得关注的点，就是默认参数在声明时就被转换为Python对象了。看看下面的例子："
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:215 ./src/3rd/pybind11/07.函数.md:233
#: ./src/3rd/pybind11/07.函数.md:239
msgid "\"myFunction\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:215 ./src/3rd/pybind11/07.函数.md:233
#: ./src/3rd/pybind11/07.函数.md:239
msgid "\"arg\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:218
msgid "这个例子里，必须保证SomeType类型已经被binding了（通过py::class\\_"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:218
msgid "），不然就会抛出异常。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:220
msgid ""
"另一个值得注意的事情就是，生成的函数签名将使用对象的`__repr__`方法来处理默认参数值。如果对象没有提供该方法，那么函数签名将不能直观的看出默认参数值。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:230
msgid "要处理这个问题，我们需要定义`SomeType.__repr__`方法，或者使用`arg_v`给默认参数手动添加方便阅读的注释。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:233
msgid "\"SomeType(123)\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:242
msgid "7.6 Keyword-only参数"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:244 ./src/3rd/pybind11/pybind11_demo.md:486
msgid "Python3提供了keyword-only参数（在函数定义中使用`*`作为匿名参数）："
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:246 ./src/3rd/pybind11/pybind11_demo.md:488
msgid "# a can be positional or via keyword; b must be via keyword\n"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:249 ./src/3rd/pybind11/07.函数.md:250
#: ./src/3rd/pybind11/07.函数.md:251 ./src/3rd/pybind11/pybind11_demo.md:491
#: ./src/3rd/pybind11/pybind11_demo.md:492
#: ./src/3rd/pybind11/pybind11_demo.md:493
msgid "# good\n"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:252 ./src/3rd/pybind11/pybind11_demo.md:494
msgid "# TypeError: f() takes 1 positional argument but 2 were given\n"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:255 ./src/3rd/pybind11/pybind11_demo.md:497
msgid "pybind11提供了`py::kw_only`对象来实现相同的功能："
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:257 ./src/3rd/pybind11/07.函数.md:267
#: ./src/3rd/pybind11/07.函数.md:283 ./src/3rd/pybind11/07.函数.md:284
#: ./src/3rd/pybind11/pybind11_demo.md:499
#: ./src/3rd/pybind11/pybind11_demo.md:509
#: ./src/3rd/pybind11/pybind11_demo.md:525
#: ./src/3rd/pybind11/pybind11_demo.md:526
msgid "\"f\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:257 ./src/3rd/pybind11/07.函数.md:267
#: ./src/3rd/pybind11/14.杂项.md:201 ./src/3rd/pybind11/15.FAQ.md:128
#: ./src/3rd/pybind11/15.FAQ.md:133 ./src/3rd/pybind11/pybind11_demo.md:499
#: ./src/3rd/pybind11/pybind11_demo.md:509
msgid "/* ... */"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:258 ./src/3rd/pybind11/07.函数.md:268
#: ./src/3rd/pybind11/13.内嵌解释器.md:214
#: ./src/3rd/pybind11/13.内嵌解释器.md:223
#: ./src/3rd/pybind11/pybind11_demo.md:500
#: ./src/3rd/pybind11/pybind11_demo.md:510
msgid "\"a\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:258 ./src/3rd/pybind11/07.函数.md:268
#: ./src/3rd/pybind11/13.内嵌解释器.md:224
#: ./src/3rd/pybind11/pybind11_demo.md:500
#: ./src/3rd/pybind11/pybind11_demo.md:510
msgid "\"b\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:261 ./src/3rd/pybind11/pybind11_demo.md:503
msgid "注意，该特性不能与`py::args`一起使用。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:263
msgid "7.7 Positional-only参数"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:265 ./src/3rd/pybind11/pybind11_demo.md:507
msgid "python3.8引入了Positional-only参数语法，pybind11通过`py::pos_only()`来提供相同的功能："
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:271 ./src/3rd/pybind11/pybind11_demo.md:513
msgid "现在，你不能通过关键字来给定`a`参数。该特性可以和keyword-only参数一起使用。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:273
msgid "7.8 Non-converting参数"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:275 ./src/3rd/pybind11/pybind11_demo.md:517
msgid "有些参数可能支持类型转换，如："
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:276 ./src/3rd/pybind11/pybind11_demo.md:518
msgid "通过`py::implicitly_convertible<A,B>()`进行隐式转换"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:277 ./src/3rd/pybind11/pybind11_demo.md:519
msgid "将整形变量传给入参为浮点类型的函数"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:278 ./src/3rd/pybind11/pybind11_demo.md:520
msgid "将非复数类型（如float）传给入参为`std::complex<float>`类型的函数"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:279 ./src/3rd/pybind11/pybind11_demo.md:521
msgid ""
"Calling a function taking an Eigen matrix reference with a numpy array of "
"the wrong type or of an incompatible data layout."
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:281 ./src/3rd/pybind11/pybind11_demo.md:523
msgid ""
"有时这种转换并不是我们期望的，我们可能更希望绑定代码抛出错误，而不是转换参数。通过`py::arg`来调用`.noconvert()`方法可以实现这个事情。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:283 ./src/3rd/pybind11/pybind11_demo.md:525
msgid "\"floats_only\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:284 ./src/3rd/pybind11/pybind11_demo.md:526
msgid "\"floats_preferred\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:287 ./src/3rd/pybind11/pybind11_demo.md:529
msgid "尝试进行转换时，将抛出`TypeError`异常："
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:293 ./src/3rd/pybind11/07.函数.md:331
#: ./src/3rd/pybind11/08.类.md:724 ./src/3rd/pybind11/pybind11_demo.md:535
msgid "\"<stdin>\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:300 ./src/3rd/pybind11/pybind11_demo.md:542
msgid "该方法可以与缩写符号`_a`和默认参数配合使用，像这样`py::arg().noconvert()`。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:302
msgid "7.9 允许/禁止空参数"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:304
msgid ""
"当函数接受由`py::class_`注册的C++类型的指针或shared "
"holder(如指针指针等)，pybind11允许将Python的None传递给函数，等同于C++中传递nullptr给函数。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:306
msgid "我们可以使用`py::arg`对象的`.none`方法来显式地使能或禁止该行为。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:311
msgid "/* Called with a Dog instance */"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:312
msgid "\"(no dog)\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:312
msgid "/* Called with None, dog == nullptr */"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:313
msgid "\"dog\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:314 ./src/3rd/pybind11/07.函数.md:316
msgid "\"meow\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:315
msgid "// Can't be called with None argument\n"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:317
msgid "\"cat\""
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:320
msgid "这样，Python调用`bark(None)`将返回`\"(no dog)\"`，调用`meow(None)`将抛出异常`TypeError`。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:325
msgid "'meow'"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:327
msgid "'(no dog)'"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:338
msgid "在不显式指定的情况下，默认支持传递`None`。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:340
msgid ""
"Note: Even when `.none(true)` is specified for an argument, `None` will be "
"converted to a `nullptr` _only_ for custom and "
"[opaque](https://pybind11.readthedocs.io/en/stable/advanced/cast/stl.html#opaque) "
"types. Pointers to built-in types (`double *`, `int *`, …) and STL types "
"(`std::vector<T> *`, …; if `pybind11/stl.h` is included) are copied when "
"converted to C++ (see "
"[Overview](https://pybind11.readthedocs.io/en/stable/advanced/cast/overview.html)) "
"and will not allow `None` as argument. To pass optional argument of these "
"copied types consider using `std::optional<T>`"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:342
msgid "7.10 重载解析顺序"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:344
msgid ""
"当一个函数或者方法拥有多个重载时，pybind11通过两个步骤来决定重载调用的次序。第一步尝试不做类型匹配各个重载函数。如果没有匹配到，第二步将允许类型转换再匹配一次（显示调用`py::arg().noconvert()`禁用类型转换的函数除外）。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:346
msgid "如果两步都失败了，将抛出异常`TypeError`。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:348
msgid "在上述两步中，重载函数将以pybind11中注册的顺序依次遍历。如果函数定义中增加了`py::prepend()`的标识，该重载函数将最先被遍历。"
msgstr ""

#: ./src/3rd/pybind11/07.函数.md:350
msgid ""
"Note: "
"pybind11不会根据重载参数的数量或类型来排优先级。换言之，pybind11不会将仅需一次类型转换的函数排在需要三次转换的函数前面，仅仅会将不需要类型转换的重载函数排在至少需要一次类型转换的函数前面。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:58
msgid "8. 类"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:60
msgid "本章将在第五章的基础上，进一步讲解类的绑定方法。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:62
msgid "8.1 在Python中重载虚函数"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:64
msgid "假设有一个含有虚函数的C++类或接口，我们想在Python中重载虚函数。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:78 ./src/3rd/pybind11/pybind11_demo.md:649
msgid "\"woof! \""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:84
msgid "现在有一个普通函数，它调用任意Animal实例的`go()`函数。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:92
msgid "pybind11绑定代码如下："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:96 ./src/3rd/pybind11/08.类.md:145
#: ./src/3rd/pybind11/08.类.md:161 ./src/3rd/pybind11/08.类.md:281
#: ./src/3rd/pybind11/14.杂项.md:108 ./src/3rd/pybind11/pybind11_demo.md:659
#: ./src/3rd/pybind11/pybind11_demo.md:707
#: ./src/3rd/pybind11/pybind11_demo.md:723
#: ./src/3rd/pybind11/pybind11_demo.md:834
#: ./src/3rd/pybind11/pybind11_demo.md:1277
msgid "\"Animal\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:97 ./src/3rd/pybind11/08.类.md:147
#: ./src/3rd/pybind11/08.类.md:163 ./src/3rd/pybind11/14.杂项.md:111
#: ./src/3rd/pybind11/pybind11_demo.md:660
#: ./src/3rd/pybind11/pybind11_demo.md:709
#: ./src/3rd/pybind11/pybind11_demo.md:725
#: ./src/3rd/pybind11/pybind11_demo.md:1280
msgid "\"go\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:102 ./src/3rd/pybind11/08.类.md:152
#: ./src/3rd/pybind11/14.杂项.md:116 ./src/3rd/pybind11/14.杂项.md:127
#: ./src/3rd/pybind11/pybind11_demo.md:665
#: ./src/3rd/pybind11/pybind11_demo.md:714
#: ./src/3rd/pybind11/pybind11_demo.md:1285
#: ./src/3rd/pybind11/pybind11_demo.md:1296
msgid "\"call_go\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:106
msgid ""
"但是，这样绑定不可扩展，当我们尝试继承Animal类时会提示\"No constructor "
"defined!\"，因为Animal无法构造。这时，我们需要类似于\"跳板(trampoline)\"的工具来重定向虚函数调用到Python中。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:108
msgid "我们可以在Python中定义一个新的Animal类作为辅助跳板："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:113 ./src/3rd/pybind11/14.杂项.md:90
#: ./src/3rd/pybind11/pybind11_demo.md:675
#: ./src/3rd/pybind11/pybind11_demo.md:1259
msgid "/* Inherit the constructors */"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:116 ./src/3rd/pybind11/14.杂项.md:93
#: ./src/3rd/pybind11/pybind11_demo.md:678
#: ./src/3rd/pybind11/pybind11_demo.md:1262
msgid "/* Trampoline (need one for each virtual function) */"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:119 ./src/3rd/pybind11/14.杂项.md:99
#: ./src/3rd/pybind11/pybind11_demo.md:681
#: ./src/3rd/pybind11/pybind11_demo.md:1268
msgid "/* Return type */"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:120 ./src/3rd/pybind11/14.杂项.md:100
#: ./src/3rd/pybind11/pybind11_demo.md:682
#: ./src/3rd/pybind11/pybind11_demo.md:1269
msgid "/* Parent class */"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:121 ./src/3rd/pybind11/pybind11_demo.md:683
msgid "/* Name of function in C++ (must match Python name) */"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:122 ./src/3rd/pybind11/14.杂项.md:102
#: ./src/3rd/pybind11/pybind11_demo.md:684
#: ./src/3rd/pybind11/pybind11_demo.md:1271
msgid "/* Argument(s) */"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:128 ./src/3rd/pybind11/pybind11_demo.md:690
msgid ""
"定义纯虚函数时需要使用`PYBIND11_OVERRIDE_PURE`宏，而有默认实现的虚函数则使用`PYBIND11_OVERRIDE`。`PYBIND11_OVERRIDE_PURE_NAME` "
"和`PYBIND11_OVERRIDE_NAME` 宏的功能类似，主要用于C函数名和Python函数名不一致的时候。以`__str__`为例："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:133 ./src/3rd/pybind11/pybind11_demo.md:695
msgid "// Return type (ret_type)\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:134 ./src/3rd/pybind11/pybind11_demo.md:696
msgid "// Parent class (cname)\n      \"__str__\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:135 ./src/3rd/pybind11/pybind11_demo.md:697
msgid "// Name of method in Python (name)\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:136 ./src/3rd/pybind11/pybind11_demo.md:698
msgid "// Name of function in C++ (fn)\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:141 ./src/3rd/pybind11/pybind11_demo.md:703
msgid "Animal类的绑定代码也需要一些微调："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:145 ./src/3rd/pybind11/08.类.md:161
#: ./src/3rd/pybind11/pybind11_demo.md:707
#: ./src/3rd/pybind11/pybind11_demo.md:723
msgid "/* <--- trampoline*/"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:156 ./src/3rd/pybind11/pybind11_demo.md:718
msgid "pybind11通过向`class_`指定额外的模板参数PyAnimal，让我们可以在Python中继承Animal类。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:158 ./src/3rd/pybind11/pybind11_demo.md:720
msgid "接下来，我们可以像往常一样定义构造函数。绑定时我们需要使用真实类，而不是辅助类。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:163 ./src/3rd/pybind11/pybind11_demo.md:725
msgid "/* <--- THIS IS WRONG, use &Animal::go */"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:166
msgid "但是，上面的改动可以让我们在Python中继承Animal类，而不能继承Dog类。后续章节将会在此基础上进一步改进。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:168 ./src/3rd/pybind11/pybind11_demo.md:728
msgid "下面的Python代码展示了我们继承并重载了`Animal::go`方法，并通过虚函数来调用它："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:173 ./src/3rd/pybind11/pybind11_demo.md:733
msgid "# u'woof! woof! woof! '\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:176 ./src/3rd/pybind11/pybind11_demo.md:736
msgid "\"meow! \""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:179 ./src/3rd/pybind11/pybind11_demo.md:739
msgid "# u'meow! meow! meow! '\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:182 ./src/3rd/pybind11/pybind11_demo.md:742
msgid ""
"如果你在派生的Python类中自定义了一个构造函数，你必须保证显示调用C++构造函数(通过`__init__`)，不管它是否为默认构造函数。否则，实例属于C++那部分的内存就未初始化，可能导致未定义行为。在pybind11 "
"2.6版本中，这种错误将会抛出`TypeError`异常。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:187 ./src/3rd/pybind11/pybind11_demo.md:747
msgid "# Without this, a TypeError is raised.\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:191 ./src/3rd/pybind11/pybind11_demo.md:751
msgid "\"yap!\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:194 ./src/3rd/pybind11/pybind11_demo.md:754
msgid ""
"注意必须显式地调用`__init__`，而不应该使用`supper()`。在一些简单的线性继承中，`supper()`或许可以正常工作；一旦你混合Python和C++类使用多重继承，由于Python "
"MRO和C++的机制，一切都将崩溃。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:196
msgid "Note："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:198
msgid "当重载函数返回一个pybind11从Python中转换过来的类型的引用或指针时，有些限制条件需要注意下："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:200
msgid ""
"because in these cases there is no C++ variable to reference (the value is "
"stored in the referenced Python variable), pybind11 provides one in the "
"PYBIND11_OVERRIDE macros (when needed) with static storage duration. Note "
"that this means that invoking the overridden method on _any_ instance will "
"change the referenced value stored in _all_ instances of that type."
msgstr ""

#: ./src/3rd/pybind11/08.类.md:201
msgid ""
"Attempts to modify a non-const reference will not have the desired effect: "
"it will change only the static cache variable, but this change will not "
"propagate to underlying Python instance, and the change will be replaced the "
"next time the override is invoked."
msgstr ""

#: ./src/3rd/pybind11/08.类.md:203
msgid "8.2 虚函数与继承"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:205 ./src/3rd/pybind11/pybind11_demo.md:758
msgid "综合考虑虚函数与继承时，你需要为每个你允许在Python派生类中重载的方法提供重载方式。下面我们扩展Animal和Dog来举例："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:211 ./src/3rd/pybind11/pybind11_demo.md:764
msgid "\"unknown\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:218 ./src/3rd/pybind11/11.类型转换.md:83
#: ./src/3rd/pybind11/pybind11_demo.md:771
msgid "\" \""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:225 ./src/3rd/pybind11/pybind11_demo.md:778
msgid ""
"上节涉及到的Animal辅助类仍是必须的，为了让Python代码能够继承`Dog`类，我们也需要为`Dog`类增加一个跳板类，来实现`bark()`和继承自Animal的`go()`、`name()`等重载方法（即便Dog类并不直接重载name方法）。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:230 ./src/3rd/pybind11/08.类.md:236
#: ./src/3rd/pybind11/08.类.md:251 ./src/3rd/pybind11/08.类.md:263
#: ./src/3rd/pybind11/pybind11_demo.md:783
#: ./src/3rd/pybind11/pybind11_demo.md:789
#: ./src/3rd/pybind11/pybind11_demo.md:804
#: ./src/3rd/pybind11/pybind11_demo.md:816
msgid "// Inherit constructors\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:243 ./src/3rd/pybind11/pybind11_demo.md:796
msgid "注意到`name()`和`bark()`尾部的逗号，这用来说明辅助类的函数不带任何参数。当函数至少有一个参数时，应该省略尾部的逗号。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:245 ./src/3rd/pybind11/pybind11_demo.md:798
msgid "注册一个继承已经在pybind11中注册的带虚函数的类，同样需要为其添加辅助类，即便它没有定义或重载任何虚函数："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:258 ./src/3rd/pybind11/pybind11_demo.md:811
msgid "我们可以使用模板辅助类将简化这类重复的绑定工作，这对有多个虚函数的基类尤其有用："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:269 ./src/3rd/pybind11/pybind11_demo.md:822
msgid ""
"// Inherit constructors\n"
"    // Override PyAnimal's pure virtual go() with a non-pure one:\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:276 ./src/3rd/pybind11/pybind11_demo.md:829
msgid "这样，我们只需要一个辅助方法来定义虚函数和纯虚函数的重载了。只是这样编译器就需要生成许多额外的方法和类。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:278 ./src/3rd/pybind11/pybind11_demo.md:831
msgid "下面我们在pybind11中注册这些类："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:283 ./src/3rd/pybind11/pybind11_demo.md:836
msgid "\"Husky\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:283 ./src/3rd/pybind11/pybind11_demo.md:836
msgid "// ... add animal, dog, husky definitions\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:287 ./src/3rd/pybind11/pybind11_demo.md:840
msgid "注意，Husky不需要一个专门的辅助类，因为它没定义任何新的虚函数和纯虚函数的重载。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:289 ./src/3rd/pybind11/pybind11_demo.md:842
msgid "Python中的使用示例："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:294 ./src/3rd/pybind11/pybind11_demo.md:847
msgid "\"yip!\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:297
msgid "8.3 扩展跳板类的功能"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:299
msgid "8.3.1 跳板类的初始化"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:301
msgid ""
"默认情况下，跳板类需要的时候才初始化，即当一个Python类继承了绑定的C++类时（而不是创建绑定类的实例时），或者注册的构造函数仅对跳板类而非注册类有效时。这主要是处于性能的考量：如果只有虚函数需要跳板类时，不初始化跳板类可以避免运行时检查Python继承类是否有重载函数，以提高性能。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:303
msgid ""
"有时，将跳板类作为一个不仅仅用于处理虚函数分发的中间类来初始化还是有用的。例如，这个类可以执行额外的初始化操作，额外的析构操作，定义属性或方法来给类提供类似Python风格的接口。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:305
msgid ""
"要让pybind11在创建类实例时，总是初始化跳板类，类的构造函数需要使用`py::init_alias<Args, "
"...>()`来代替`py::init<Args, ...>()`。这样可以强制通过跳板类来构造，确保类成员的初始化和析构。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:307
msgid ""
"**See also**：See the file `tests/test_virtual_functions.cpp` for complete "
"examples showing both normal and forced trampoline instantiation."
msgstr ""

#: ./src/3rd/pybind11/08.类.md:309
msgid "差异化函数签名"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:311
msgid ""
"第一节中介绍的宏可以覆盖绝大多数公开C++类的场景。有时，我们难以创建参数和返回类型间的一一映射关系。如C++的参数即是输入又是输出的情况（入参为引用，在函数中修改该参数）。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:313
msgid ""
"我们可以通过跳板类来解决这种Python方法输入和输出的问题，也可以参考 [Limitations involving reference "
"arguments](https://pybind11.readthedocs.io/en/stable/faq.html#faq-reference-arguments)中的处理方法。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:315
msgid ""
"`get_override()`函数允许Python从跳板类方法中检索方法的实现。Consider for example a C++ method "
"which has the signature `bool myMethod(int32_t& value)`, where the return "
"indicates whether something should be done with the `value`. This can be "
"made convenient on the Python side by allowing the Python function to return "
"`None` or an `int`:"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:320
msgid ""
"// Acquire the GIL while in this scope.\n"
"    // Try to look up the overridden method on the Python side.\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:322
msgid "\"myMethod\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:323
msgid "// method is found\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:324
msgid "// Call the Python function.\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:325
msgid "// check if it returned a Python integer type\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:326
msgid "// Cast it and assign it to the value.\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:327
msgid "// Return true; value should be used.\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:329
msgid "// Python returned none, return false.\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:332
msgid "// Alternatively return MyClass::myMethod(value);\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:336
msgid "8.4 定制构造函数"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:338
msgid ""
"前面章节介绍了绑定构造函数的方法，但它仅仅在C++侧刚好有对应的函数时才能正常工作。为了扩展到更通用的情况，pybind11可以绑定工厂方法作为构造函数。如下所示："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:343 ./src/3rd/pybind11/08.类.md:358
msgid "// private constructor\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:345
msgid "// Factory function:\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:349 ./src/3rd/pybind11/08.类.md:369
#: ./src/3rd/pybind11/08.类.md:403 ./src/3rd/pybind11/10.智能指针.md:83
msgid "\"Example\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:353
msgid ""
"虽然可以直接绑定`create`方法，有时将其在Python侧将其作为构造函数公开更为合适。这可以通过调用`.def(py::init(...))`来完成，只需将对应的函数（返回一个新实例，如create）作为参数传入`py::init()`即可。同样的，用这个方法我们也可以传入一个函数，它返回新实例的原始指针或持有者（如\\``std::unique_ptr\\`）。如下所示："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:360
msgid "// Factory function - returned by value:\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:363
msgid "// These constructors are publicly callable:\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:370
msgid "// Bind the factory function as a constructor:\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:372
msgid "// Bind a lambda function returning a pointer wrapped in a holder:\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:376
msgid "// Return a raw pointer:\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:378
msgid "// You can mix the above with regular C++ constructor bindings as well:\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:383
msgid "当Python侧调用这些构造函数时，pybind11将调用工厂函数，并将返回的C++示例存储到Python实例中。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:385
msgid ""
"当与重载函数跳板类结合使用时，有两种方法。第一种方法是跳板类增加一个构造函数，函数接受原类的右值引用，这样我们可以从原类的工厂函数构造跳板类的实例。第二种方法是使用`py::init()`提供原类和跳板类两个工厂函数。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:387
msgid "你也可以指定一个工厂函数，它总是返回跳板类的实例，这与`py::init_alias<...>`的行为类似。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:389
msgid "下面的示例展示了这两种方法："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:392
msgid "<pybind11/factory.h>"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:395 ./src/3rd/pybind11/09.异常.md:283
#: ./src/3rd/pybind11/11.类型转换.md:508
#: ./src/3rd/pybind11/12.Python的C++接口.md:406
#: ./src/3rd/pybind11/12.Python的C++接口.md:409
#: ./src/3rd/pybind11/pybind11_demo.md:1207
msgid "// ...\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:404
msgid ""
"// Returns an Example pointer.  If a PyExample is needed, the Example\n"
"    // instance will be moved via the extra constructor in PyExample, "
"above.\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:407
msgid "// Two callbacks:\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:408
msgid "/* no alias needed */"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:409
msgid "/* alias needed */"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:410
msgid "// *Always* returns an alias instance (like py::init_alias<>())\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:415
msgid "大括号初始化"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:417
msgid "`pybind11`潜在地使用C++11的大括号初始化来调用目标类的构造函数，这意味着它也可以绑定隐式的构造函数："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:425
msgid "\"Aggregate\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:429
msgid ""
"Note: "
"大括号初始化优先匹配带列表初始化的重载构造函数。极少数情况下会出问题，你可以使用`py::init(...)`传入一个构造新对象的匿名函数来处理这个问题。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:431
msgid "8.5 非公有析构函数"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:433 ./src/3rd/pybind11/pybind11_demo.md:852
msgid ""
"如果一个类拥有私有或保护的析构函数（例如单例类），通过pybind11绑定类时编译器将会报错。本质的问题是`std::unique_ptr`智能指针负责管理实例的生命周期需要引用析构函数，即便没有资源需要回收。Pybind11提供了辅助类`py::nodelete`来禁止对析构函数的调用。这种情况下，C++侧负责析构对象避免内存泄漏就十分重要。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:436 ./src/3rd/pybind11/11.类型转换.md:453
#: ./src/3rd/pybind11/pybind11_demo.md:855
msgid "/* ... definition ... */"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:442 ./src/3rd/pybind11/11.类型转换.md:458
#: ./src/3rd/pybind11/pybind11_demo.md:861
msgid "/* ... binding code ... */"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:449
msgid "8.6 在析构函数中调用Python"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:451
msgid ""
"在析构函数中调用Python函数出错时，会抛出异常`error_already_set`。如果异常在析构函数外抛出，将会调用`std::terminate()`来终结程序。因此，类析构函数必须捕获所有`error_already_set`类型的异常，并使用`error_already_set::discard_as_unraisable()`来丢弃Python异常。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:453
msgid ""
"任意Python函数都可能抛出异常。比如一个Python生成器停止生成条目时，Pyhton将抛出`StopIteration`异常，如果生成器的堆栈持有C++对象的最后一个引用时，它将传递异常到C++析构函数。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:460
msgid "\"Even printing is dangerous in a destructor\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:461
msgid "\"raise ValueError('This is an unraisable exception')\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:463
msgid ""
"// error_context should be information about where/why the occurred,\n"
"            // e.g. use __func__ to get the name of the current function\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:471
msgid "Note: pybind11不支持将C++析构函数标识为`noexcept(false)`。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:473
msgid "8.7 隐式转换"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:475
msgid "假设有A和B两个类，A可以直接转换为B。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:478 ./src/3rd/pybind11/08.类.md:777
#: ./src/3rd/pybind11/08.类.md:794 ./src/3rd/pybind11/08.类.md:821
#: ./src/3rd/pybind11/11.类型转换.md:331
#: ./src/3rd/pybind11/pybind11_demo.md:873
#: ./src/3rd/pybind11/pybind11_demo.md:996
#: ./src/3rd/pybind11/pybind11_demo.md:1013
#: ./src/3rd/pybind11/pybind11_demo.md:1040
msgid "\"A\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:479 ./src/3rd/pybind11/08.类.md:483
#: ./src/3rd/pybind11/pybind11_demo.md:874
#: ./src/3rd/pybind11/pybind11_demo.md:878
msgid "/// ... members ...\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:481 ./src/3rd/pybind11/pybind11_demo.md:876
msgid "\"B\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:485 ./src/3rd/pybind11/pybind11_demo.md:880
msgid "\"func\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:486 ./src/3rd/pybind11/pybind11_demo.md:881
msgid "/* .... */"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:490 ./src/3rd/pybind11/pybind11_demo.md:885
msgid ""
"如果想func函数传入A类型的参数a，Pyhton侧需要这样写`func(B(a))`，而C++则可以直接使用`func(a)`，自动将A类型转换为B类型。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:492 ./src/3rd/pybind11/pybind11_demo.md:887
msgid "这种情形下（B有一个接受A类型参数的构造函数），我们可以使用如下声明来让Python侧也支持类似的隐式转换："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:498
msgid "Note: A到B的隐式转换仅在通过pybind11绑定了B类型的条件下有效。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:500
msgid ""
"为了防止失控的递归调用，隐式转换时不可重入的：an implicit conversion invoked as part of another "
"implicit conversion of the same type (i.e. from `A` to `B`) will fail."
msgstr ""

#: ./src/3rd/pybind11/08.类.md:502
msgid "8.8 静态属性"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:504
msgid ""
"静态属性也可以像普通属性一样公开getter和setter方法。隐式的self参数仍然存在，并在Python中用于传递Python`type`子类实例。我们通常在C++侧忽略这个参数，下面的例子演示了如何使用lambda表达式做为getter函数，并忽略self参数。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:507
msgid "\"Foo\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:508
msgid "/* self */"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:511
msgid "8.9 重载操作符"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:513 ./src/3rd/pybind11/pybind11_demo.md:895
msgid "假设有这样一个类`Vector2`，它通过重载操作符实现了向量加法和标量乘法。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:530 ./src/3rd/pybind11/pybind11_demo.md:912
msgid "\"[\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:530 ./src/3rd/pybind11/pybind11_demo.md:912
msgid "\"]\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:537 ./src/3rd/pybind11/pybind11_demo.md:919
msgid "操作符绑定代码如下："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:540
msgid "<pybind11/operators.h>"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:543 ./src/3rd/pybind11/pybind11_demo.md:925
msgid "\"Vector2\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:555 ./src/3rd/pybind11/pybind11_demo.md:937
msgid "`.def(py::self * float())`是如下代码的简短标记："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:558 ./src/3rd/pybind11/pybind11_demo.md:940
msgid "\"__mul__\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:563
msgid "8.10 支持pickle"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:565
msgid ""
"Python的`pickle`模块提供了强大的将Python对象图到二进制数据流的序列化和反序列化的功能。pybind11也提供了`py::pickle()`定义来支持pickle和unpickle "
"C++类。现在有这样一个类："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:581
msgid ""
"Python中通过定义`__setstate__`和`__getstate__`使能pciking支持。对于pybind11类，可以使用`py::pickle()`来绑定这两个函数："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:584
msgid "\"Pickleable\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:586
msgid "\"value\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:587
msgid "\"extra\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:588
msgid "\"setExtra\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:590
msgid ""
"// __getstate__\n"
"            /* Return a tuple that fully encodes the state of the object */"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:594
msgid "// __setstate__\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:596
msgid "\"Invalid state!\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:598
msgid "/* Create a new C++ instance */"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:601
msgid "/* Assign any additional state */"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:609
msgid ""
"`py::pickle()`中的`__setstate__`部分遵循与`py::init()`单参数版本相同的规则，返回值可以是一个值，指针或者holder "
"type。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:615
msgid "# Use cPickle on Python 2.7\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:619
msgid "\"test_value\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:624
msgid "Note: Note that only the cPickle module is supported on Python 2.7."
msgstr ""

#: ./src/3rd/pybind11/08.类.md:626
msgid ""
"The second argument to `dumps` is also crucial: it selects the pickle "
"protocol version 2, since the older version 1 is not supported. Newer "
"versions are also fine—for instance, specify `-1` to always use the latest "
"available version. Beware: failure to follow these instructions will cause "
"important pybind11 memory allocation routines to be skipped during "
"unpickling, which will likely lead to memory corruption and/or segmentation "
"faults."
msgstr ""

#: ./src/3rd/pybind11/08.类.md:628
msgid "8.11 深拷贝支持"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:630
msgid "Python通常在赋值中使用引用。有时需要一个真正的拷贝，以防止修改所有的拷贝实例。Python的`copy`模块提供了这样的拷贝能力。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:632
msgid ""
"在Python3中，带pickle支持的类自带深拷贝能力。但是，自定义`__copy__`和`__deepcopy__`方法能够提高拷贝的性能。在Python2.7中，由于pybind11只支持cPickle，要想实现深拷贝，用户必须实现这个两个方法。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:634 ./src/3rd/pybind11/pybind11_demo.md:951
msgid "对于一些简单的类，可以使用拷贝构造函数来实现深拷贝。如下所示："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:637 ./src/3rd/pybind11/pybind11_demo.md:954
msgid "\"Copyable\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:638 ./src/3rd/pybind11/pybind11_demo.md:955
msgid "\"__copy__\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:641 ./src/3rd/pybind11/pybind11_demo.md:958
msgid "\"__deepcopy__\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:643 ./src/3rd/pybind11/pybind11_demo.md:960
msgid "\"memo\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:646 ./src/3rd/pybind11/pybind11_demo.md:963
msgid "Note: 本例中不会复制动态属性。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:648
msgid "8.12 多重继承"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:650 ./src/3rd/pybind11/pybind11_demo.md:967
msgid "pybind11支持绑定多重继承的类，只需在将所有基类作为`class_`的模板参数即可："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:653 ./src/3rd/pybind11/08.类.md:664
#: ./src/3rd/pybind11/pybind11_demo.md:970
#: ./src/3rd/pybind11/pybind11_demo.md:981
msgid "\"MyType\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:657 ./src/3rd/pybind11/pybind11_demo.md:974
msgid "基类间的顺序任意，甚至可以穿插使用别名或者holder类型，pybind11能够自动识别它们。唯一的要求就是第一个模板参数必须是类型本身。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:659 ./src/3rd/pybind11/pybind11_demo.md:976
msgid "允许Python中定义的类继承多个C++类，也允许混合继承C++类和Python类。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:661 ./src/3rd/pybind11/pybind11_demo.md:978
msgid ""
"有一个关于该特性实现的警告：当仅指定一个基类，实际上有多个基类时，pybind11会认为它并没有使用多重继承，这将导致未定义行为。对于这个问题，我们可以在类构造函数中添加`multiple_inheritance`的标识。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:667 ./src/3rd/pybind11/pybind11_demo.md:984
msgid "当模板参数列出了多个基类时，无需使用该标识。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:669
msgid "8.13 绑定Module-local类"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:671
msgid "pybind11默认将类绑定到模块的全局作用域中。这意味着模块中定义的类型，可能获得其他模块中相同类型名的结果。示例如下："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:674
msgid "// In the module1.cpp binding code for module1:\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:678
msgid "// In the module2.cpp binding code for module2:\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:680
msgid "\"create_pet\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:686
msgid "\"Kitty\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:687
msgid "\"Doggy\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:688
msgid "'Doggy'"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:692
msgid "有时，我们希望将一个复杂的库分割到几个Python模块中。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:694
msgid ""
"在某些例子中，这也会引起冲突。例如，有两个不相干的模块使用了同一个C++外部库，而且他们各自提供了这个库的自定义绑定。当Python程序同时（直接或间接地）导入两个库时，由于外部类型的定义冲突而导致错误。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:697
msgid "// dogs.cpp\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:698 ./src/3rd/pybind11/08.类.md:710
msgid "// Binding for external library class:\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:702
msgid "// Binding for local extension class:\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:709
msgid "// cats.cpp, in a completely separate project from the above dogs.cpp.\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:714
msgid "// Binding for local extending class:\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:728
msgid "为避开这点，你可以想`py::class_`传递`py::module_local()`属性，将外部类绑定到模块内部。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:731
msgid "// Pet binding in dogs.cpp:\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:737
msgid "// Pet binding in cats.cpp:\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:742
msgid ""
"这样，Python侧的`dogs.Pet`和`cats.Pet`就是两个不同的类，两个模块也能顺利地同时导入，互不干扰。有两点需要注意的是：1）外部模块不能返回或转换`Pet`示例到Python（除非他们也提供自己内部的绑定）；2）在Python的视角来看，他们就是两个截然不同的类。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:744
msgid ""
"注意，这个局部性仅作用于C++到Python方向。传递一个`py::module_local`类型到C++函数，在module-local类看来仍是合理的。这意味着，下面的函数添加到任意哪个模块（不限于cats和dogs两个模块），它将可以通过`dogs.Pet`或`cats.Pet`参数来调用。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:747
msgid "\"pet_name\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:750
msgid "举个例子，假设上述函数被添加到`cats.cpp`，`dogs.cpp`和`frogs.cpp`（`frogs.cpp`没有绑定`Pets`类）。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:753
msgid "# No error because of the added py::module_local()\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:754
msgid "\"Fluffy\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:754
msgid "\"Rover\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:756 ./src/3rd/pybind11/08.类.md:758
#: ./src/3rd/pybind11/08.类.md:758
msgid "'Fluffy'"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:756 ./src/3rd/pybind11/08.类.md:758
msgid "'Rover'"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:761
msgid ""
"即便其他模块已经全局地注册了相同的类型，我们还是可以使用`py::module_local()`来注册到另一个模块：在module-local定义的模块，所有C++势力将被转为关联的Python类型。在其他模块，这个实例则被转为全局地Python类型。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:763
msgid ""
"Note: STL bindings (as provided via the optional `pybind11/stl_bind.h` "
"header) apply `py::module_local` by default when the bound type might "
"conflict with other modules; see [Binding STL "
"containers](https://pybind11.readthedocs.io/en/stable/advanced/cast/stl.html#stl-bind) "
"for details."
msgstr ""

#: ./src/3rd/pybind11/08.类.md:765
msgid ""
"The localization of the bound types is actually tied to the shared object or "
"binary generated by the compiler/linker. For typical modules created with "
"`PYBIND11_MODULE()`, this distinction is not significant. It is possible, "
"however, when [Embedding the "
"interpreter](https://pybind11.readthedocs.io/en/stable/advanced/embedding.html#embedding) "
"to embed multiple modules in the same binary (see [Adding embedded "
"modules](https://pybind11.readthedocs.io/en/stable/advanced/embedding.html#embedding-modules)). "
"In such a case, the localization will apply across all embedded modules "
"within the same binary."
msgstr ""

#: ./src/3rd/pybind11/08.类.md:767
msgid "8. 14 绑定protected成员函数"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:769 ./src/3rd/pybind11/pybind11_demo.md:988
msgid "通常不可能向Python公开protected 成员函数："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:778 ./src/3rd/pybind11/pybind11_demo.md:997
msgid "// error: 'foo' is a protected member of 'A'\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:781 ./src/3rd/pybind11/pybind11_demo.md:1000
msgid "因为非公有成员函数意味着外部不可调用。但我们还是希望在Python派生类中使用protected 函数。我们可以通过下面的方式来实现："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:789 ./src/3rd/pybind11/pybind11_demo.md:1008
msgid "// helper type for exposing protected functions\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:791 ./src/3rd/pybind11/pybind11_demo.md:1010
msgid "// inherited with different access modifier\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:794 ./src/3rd/pybind11/pybind11_demo.md:1013
msgid "// bind the primary class\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:795 ./src/3rd/pybind11/pybind11_demo.md:1014
msgid "// expose protected methods via the publicist\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:798 ./src/3rd/pybind11/pybind11_demo.md:1017
msgid ""
"因为 `&Publicist::foo` 和`&A::foo` 准确地说是同一个函数（相同的签名和地址），仅仅是获取方式不同。 `Publicist` "
"的唯一意图，就是将函数的作用域变为`public`。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:800 ./src/3rd/pybind11/pybind11_demo.md:1019
msgid ""
"如果是希望公开在Python侧重载的 `protected`虚函数，可以将publicist pattern与之前提到的trampoline相结合："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:821 ./src/3rd/pybind11/pybind11_demo.md:1040
msgid "// <-- `Trampoline` here\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:822 ./src/3rd/pybind11/pybind11_demo.md:1041
msgid "// <-- `Publicist` here, not `Trampoline`!\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:825
msgid "8.15 绑定final类"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:827 ./src/3rd/pybind11/pybind11_demo.md:1046
msgid ""
"在C++11中，我们可以使用`findal`关键字来确保一个类不被继承。`py::is_final`属性则可以用来确保一个类在Python中不被继承。底层的C++类型不需要定义为final。"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:832 ./src/3rd/pybind11/pybind11_demo.md:1051
msgid "\"IsFinal\""
msgstr ""

#: ./src/3rd/pybind11/08.类.md:835 ./src/3rd/pybind11/pybind11_demo.md:1054
msgid "在Python中试图继承这个类，将导致错误："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:841 ./src/3rd/pybind11/pybind11_demo.md:1060
msgid "'IsFinal'"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:844
msgid "8.16 定制自动向下转型"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:846
msgid ""
"如前面“继承与自动转型”一节中解释的，pybind11内置了对C++多态的动态类型的处理。Sometimes, you might want to "
"provide this automatic downcasting behavior when creating bindings for a "
"class hierarchy that does not use standard C++ polymorphism, such as LLVM. "
"As long as there’s some way to determine at runtime whether a downcast is "
"safe, you can proceed by specializing the `pybind11::polymorphic_type_hook` "
"template:"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:850
msgid "// Not polymorphic: has no virtual methods\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:865
msgid "// note that src may be nullptr\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:873
msgid "// namespace pybind11\n"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:876
msgid ""
"When pybind11 wants to convert a C++ pointer of type `Base*` to a Python "
"object, it calls `polymorphic_type_hook<Base>::get()` to determine if a "
"downcast is possible. The `get()` function should use whatever runtime "
"information is available to determine if its `src` parameter is in fact an "
"instance of some class `Derived` that inherits from `Base`. If it finds such "
"a `Derived`, it sets `type = &typeid(Derived)` and returns a pointer to the "
"`Derived` object that contains `src`. Otherwise, it just returns `src`, "
"leaving `type` at its default value of nullptr. If you set `type` to a type "
"that pybind11 doesn’t know about, no downcasting will occur, and the "
"original `src` pointer will be used with its static type `Base*`."
msgstr ""

#: ./src/3rd/pybind11/08.类.md:878
msgid ""
"It is critical that the returned pointer and `type` argument of `get()` "
"agree with each other: if `type` is set to something non-null, the returned "
"pointer must point to the start of an object whose type is `type`. If the "
"hierarchy being exposed uses only single inheritance, a simple `return src;` "
"will achieve this just fine, but in the general case, you must cast `src` to "
"the appropriate derived-class pointer (e.g. using "
"`static_cast<Derived>(src)`) before allowing it to be returned as a `void*`."
msgstr ""

#: ./src/3rd/pybind11/08.类.md:880
msgid "8.17 访问类型对象"
msgstr ""

#: ./src/3rd/pybind11/08.类.md:882
msgid "我们可以从已注册的C++类，获取到类型对象："
msgstr ""

#: ./src/3rd/pybind11/08.类.md:888
msgid "也可以直接使用`py::type::of(ob)`来获取任意Python对象的类型，跟Python中的`type(ob)`一样。"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:58
msgid "9. 异常"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:60
msgid "9.1 C++内置异常到Python异常的转换"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:62 ./src/3rd/pybind11/pybind11_demo.md:1067
msgid ""
"当Python通过pybind11调用C++代码时，pybind11将捕获C++异常，并将其翻译为对应的Python异常后抛出。这样Python代码就能够处理它们。"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:64 ./src/3rd/pybind11/pybind11_demo.md:1069
msgid ""
"pybind11定义了`std::exception`及其标准子类，和一些特殊异常到Python异常的翻译。由于它们不是真正的Python异常，所以不能使用Python "
"C API来检查。相反，它们是纯C++异常，当它们到达异常处理器时，pybind11将其翻译为对应的Python异常。"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:66 ./src/3rd/pybind11/pybind11_demo.md:1071
msgid "Exception thrown by C++"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:66 ./src/3rd/pybind11/pybind11_demo.md:1071
msgid "Translated to Python exception type"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:68 ./src/3rd/pybind11/pybind11_demo.md:1073
msgid "`std::exception`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:68 ./src/3rd/pybind11/09.异常.md:84
#: ./src/3rd/pybind11/pybind11_demo.md:1073
#: ./src/3rd/pybind11/pybind11_demo.md:1089
msgid "`RuntimeError`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:69 ./src/3rd/pybind11/pybind11_demo.md:1074
msgid "`std::bad_alloc`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:69 ./src/3rd/pybind11/pybind11_demo.md:1074
msgid "`MemoryError`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:70 ./src/3rd/pybind11/pybind11_demo.md:1075
msgid "`std::domain_error`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:70 ./src/3rd/pybind11/09.异常.md:71
#: ./src/3rd/pybind11/09.异常.md:72 ./src/3rd/pybind11/09.异常.md:74
#: ./src/3rd/pybind11/pybind11_demo.md:1075
#: ./src/3rd/pybind11/pybind11_demo.md:1076
#: ./src/3rd/pybind11/pybind11_demo.md:1077
#: ./src/3rd/pybind11/pybind11_demo.md:1079
msgid "`ValueError`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:71 ./src/3rd/pybind11/pybind11_demo.md:1076
msgid "`std::invalid_argument`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:72 ./src/3rd/pybind11/pybind11_demo.md:1077
msgid "`std::length_error`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:73 ./src/3rd/pybind11/pybind11_demo.md:1078
msgid "`std::out_of_range`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:73 ./src/3rd/pybind11/pybind11_demo.md:1078
msgid "`IndexError`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:74 ./src/3rd/pybind11/pybind11_demo.md:1079
msgid "`std::range_error`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:75 ./src/3rd/pybind11/pybind11_demo.md:1080
msgid "`std::overflow_error`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:75 ./src/3rd/pybind11/pybind11_demo.md:1080
msgid "`OverflowError`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:76 ./src/3rd/pybind11/pybind11_demo.md:1081
msgid "`pybind11::stop_iteration`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:76 ./src/3rd/pybind11/pybind11_demo.md:1081
msgid "`StopIteration` (used to implement custom iterators)"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:77 ./src/3rd/pybind11/pybind11_demo.md:1082
msgid "`pybind11::index_error`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:77 ./src/3rd/pybind11/pybind11_demo.md:1082
msgid ""
"`IndexError` (used to indicate out of bounds access in `__getitem__`, "
"`__setitem__`, etc.)"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:78 ./src/3rd/pybind11/pybind11_demo.md:1083
msgid "`pybind11::key_error`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:78 ./src/3rd/pybind11/pybind11_demo.md:1083
msgid ""
"`KeyError` (used to indicate out of bounds access in `__getitem__`, "
"`__setitem__` in dict-like objects, etc.)"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:79 ./src/3rd/pybind11/pybind11_demo.md:1084
msgid "`pybind11::value_error`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:79 ./src/3rd/pybind11/pybind11_demo.md:1084
msgid ""
"`ValueError` (used to indicate wrong value passed in `container.remove(...)`)"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:80 ./src/3rd/pybind11/pybind11_demo.md:1085
msgid "`pybind11::type_error`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:80 ./src/3rd/pybind11/pybind11_demo.md:1085
msgid "`TypeError`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:81 ./src/3rd/pybind11/pybind11_demo.md:1086
msgid "`pybind11::buffer_error`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:81 ./src/3rd/pybind11/pybind11_demo.md:1086
msgid "`BufferError`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:82 ./src/3rd/pybind11/pybind11_demo.md:1087
msgid "`pybind11::import_error`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:82 ./src/3rd/pybind11/pybind11_demo.md:1087
msgid "`ImportError`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:83 ./src/3rd/pybind11/pybind11_demo.md:1088
msgid "`pybind11::attribute_error`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:83 ./src/3rd/pybind11/pybind11_demo.md:1088
msgid "`AttributeError`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:84 ./src/3rd/pybind11/pybind11_demo.md:1089
msgid "Any other exception"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:86 ./src/3rd/pybind11/pybind11_demo.md:1091
msgid ""
"异常翻译不是双向的。即上述异常不会捕获源自Python的异常。Python的异常，需要捕获`pybind11::error_already_set`。"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:88 ./src/3rd/pybind11/pybind11_demo.md:1093
msgid "这里有个特殊的异常，当入参不能转化为Python对象时，`handle::call()`将抛出`cast_error`异常。"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:90
msgid "9.2 注册自定义异常翻译"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:92 ./src/3rd/pybind11/pybind11_demo.md:1097
msgid ""
"如果上述默认异常转换策略不够用，pybind11也提供了注册自定义异常翻译的支持。类似于pybind11 "
"class，异常翻译也可以定义在模块内或global。要注册一个使用C++异常的`what()`方法将C++到Python的异常转换，可以使用下面的方法："
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:95 ./src/3rd/pybind11/09.异常.md:103
#: ./src/3rd/pybind11/09.异常.md:109 ./src/3rd/pybind11/09.异常.md:110
#: ./src/3rd/pybind11/pybind11_demo.md:1100
#: ./src/3rd/pybind11/pybind11_demo.md:1108
#: ./src/3rd/pybind11/pybind11_demo.md:1114
#: ./src/3rd/pybind11/pybind11_demo.md:1115
msgid "\"PyExp\""
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:98 ./src/3rd/pybind11/pybind11_demo.md:1103
msgid "这个调用在指定模块创建了一个名称为PyExp的Python异常，并自动将CppExp相关的异常转换为PyExp异常。"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:100 ./src/3rd/pybind11/pybind11_demo.md:1105
msgid "相似的函数可以注册模块内的异常翻译："
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:106 ./src/3rd/pybind11/pybind11_demo.md:1111
msgid "方法的第三个参数handle可以指定异常的基类："
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:113 ./src/3rd/pybind11/pybind11_demo.md:1118
msgid "这样，PyExp异常可以捕获PyExp和RuntimeError。"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:115 ./src/3rd/pybind11/pybind11_demo.md:1120
msgid ""
"Python内置的异常类型可以参考Python文档[Standard "
"Exceptions](https://docs.python.org/3/c-api/exceptions.html#standard-exceptions)，默认的基类为`PyExc_Exception`。"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:117 ./src/3rd/pybind11/pybind11_demo.md:1122
msgid ""
"`py::register_exception_translator(translator)` "
"和`py::register_local_exception_translator(translator)` "
"提供了更高级的异常翻译功能，它可以注册任意的异常类型。函数接受一个无状态的回调函数`void(std::exception_ptr)`。"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:119
msgid "C++异常抛出时，注册的异常翻译类将以注册时相反的顺序匹配，优先匹配模块内翻译类，然后再是全局翻译类。"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:121
msgid ""
"Inside the translator, `std::rethrow_exception` should be used within a try "
"block to re-throw the exception. One or more catch clauses to catch the "
"appropriate exceptions should then be used with each clause using "
"`PyErr_SetString` to set a Python exception or `ex(string)` to set the "
"python exception to a custom exception type (see below)."
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:123
msgid ""
"To declare a custom Python exception type, declare a `py::exception` "
"variable and use this in the associated exception translator (note: it is "
"often useful to make this a static declaration when using it inside a lambda "
"expression without requiring capturing)."
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:125
msgid ""
"The following example demonstrates this for a hypothetical exception classes "
"`MyCustomException` and `OtherException`: the first is translated to a "
"custom python exception `MyCustomError`, while the second is translated to a "
"standard python RuntimeError:"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:127
msgid ""
"```\n"
"static py::exception<MyCustomException> exc(m, \"MyCustomError\");\n"
"py::register_exception_translator([](std::exception_ptr p) {\n"
"    try {\n"
"        if (p) std::rethrow_exception(p);\n"
"    } catch (const MyCustomException &e) {\n"
"        exc(e.what());\n"
"    } catch (const OtherException &e) {\n"
"        PyErr_SetString(PyExc_RuntimeError, e.what());\n"
"    }\n"
"});\n"
"```"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:140
msgid ""
"Multiple exceptions can be handled by a single translator, as shown in the "
"example above. If the exception is not caught by the current translator, the "
"previously registered one gets a chance."
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:142
msgid ""
"If none of the registered exception translators is able to handle the "
"exception, it is handled by the default converter as described in the "
"previous section."
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:144
msgid "9.3 Local vs Global Exception Translators"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:146
msgid ""
"When a global exception translator is registered, it will be applied across "
"all modules in the reverse order of registration. This can create behavior "
"where the order of module import influences how exceptions are translated."
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:148
msgid "If module1 has the following translator:"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:150
msgid ""
"```\n"
"py::register_exception_translator([](std::exception_ptr p) {\n"
"  try {\n"
"      if (p) std::rethrow_exception(p);\n"
"  } catch (const std::invalid_argument &e) {\n"
"      PyErr_SetString(\"module1 handled this\")\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:160
msgid "and module2 has the following similar translator:"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:162
msgid ""
"```\n"
"py::register_exception_translator([](std::exception_ptr p) {\n"
"  try {\n"
"      if (p) std::rethrow_exception(p);\n"
"  } catch (const std::invalid_argument &e) {\n"
"      PyErr_SetString(\"module2 handled this\")\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:172
msgid ""
"then which translator handles the invalid_argument will be determined by the "
"order that module1 and module2 are imported. Since exception translators are "
"applied in the reverse order of registration, which ever module was imported "
"last will “win” and that translator will be applied."
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:174
msgid ""
"If there are multiple pybind11 modules that share exception types (either "
"standard built-in or custom) loaded into a single python instance and "
"consistent error handling behavior is needed, then local translators should "
"be used."
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:176
msgid ""
"Changing the previous example to use `register_local_exception_translator` "
"would mean that when invalid_argument is thrown in the module2 code, the "
"module2 translator will always handle it, while in module1, the module1 "
"translator will do the same."
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:178
msgid "9.4 在C++中处理Python异常"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:180 ./src/3rd/pybind11/pybind11_demo.md:1126
msgid ""
"当C++调用Python函数时（回调函数或者操作Python对象），若Python有异常抛出，pybind11会将Python异常转化为`pybind11::error_already_set`类型的异常，它包含了一个C++字符串描述和实际的Python异常。`error_already_set`用于将Python异常传回Python（或者在C++侧处理）。"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:182 ./src/3rd/pybind11/pybind11_demo.md:1128
msgid "Exception raised in Python"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:182 ./src/3rd/pybind11/pybind11_demo.md:1128
msgid "Thrown as C++ exception type"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:184 ./src/3rd/pybind11/pybind11_demo.md:1130
msgid "Any Python `Exception`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:184 ./src/3rd/pybind11/pybind11_demo.md:1130
msgid "`pybind11::error_already_set`"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:186 ./src/3rd/pybind11/pybind11_demo.md:1132
msgid "举个例子："
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:190 ./src/3rd/pybind11/pybind11_demo.md:1136
msgid "// open(\"missing.txt\", \"r\")\n"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:191 ./src/3rd/pybind11/pybind11_demo.md:1137
msgid "\"io\""
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:191 ./src/3rd/pybind11/pybind11_demo.md:1137
msgid "\"open\""
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:191 ./src/3rd/pybind11/pybind11_demo.md:1137
msgid "\"missing.txt\""
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:191 ./src/3rd/pybind11/pybind11_demo.md:1137
msgid "\"r\""
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:192 ./src/3rd/pybind11/pybind11_demo.md:1138
msgid "\"read\""
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:193 ./src/3rd/pybind11/pybind11_demo.md:1139
msgid "\"close\""
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:196 ./src/3rd/pybind11/pybind11_demo.md:1142
msgid "\"missing.txt not found\""
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:198 ./src/3rd/pybind11/pybind11_demo.md:1144
msgid "\"missing.txt found but not accessible\""
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:205 ./src/3rd/pybind11/pybind11_demo.md:1151
msgid "该方法并不适用与C++到Python的翻译，Python侧抛出的异常总是被翻译为`error_already_set`."
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:209 ./src/3rd/pybind11/pybind11_demo.md:1155
msgid "\"raise ValueError('The Ring')\""
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:211 ./src/3rd/pybind11/pybind11_demo.md:1157
msgid "// Boromir never gets the ring\n"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:214 ./src/3rd/pybind11/pybind11_demo.md:1160
msgid "// Frodo gets the ring\n"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:215 ./src/3rd/pybind11/pybind11_demo.md:1161
msgid "\"I will take the ring\""
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:219 ./src/3rd/pybind11/pybind11_demo.md:1165
msgid ""
"// py::value_error is a request for pybind11 to raise a Python exception\n"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:220 ./src/3rd/pybind11/pybind11_demo.md:1166
msgid "\"The ball\""
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:222 ./src/3rd/pybind11/pybind11_demo.md:1168
msgid ""
"// cat won't catch the ball since\n"
"    // py::value_error is not a Python exception\n"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:226 ./src/3rd/pybind11/pybind11_demo.md:1172
msgid "// dog will catch the ball\n"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:227 ./src/3rd/pybind11/pybind11_demo.md:1173
msgid "\"Run Spot run\""
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:228 ./src/3rd/pybind11/pybind11_demo.md:1174
msgid "// Throw it again (pybind11 will raise ValueError)\n"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:232
msgid "9.5 处理Python C API的错误"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:234 ./src/3rd/pybind11/pybind11_demo.md:1180
msgid ""
"尽可能地使用pybind11 wrappers代替直接调用Python C API。如果确实需要直接使用Python C "
"API，除了需要手动管理引用计数外，还必须遵守pybind11的错误处理协议。"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:236 ./src/3rd/pybind11/pybind11_demo.md:1182
msgid ""
"在调用Python C API后，如果Python返回错误，需要调用`throw "
"py::error_already_set();`语句，让pybind11来处理异常并传递给Python解释器。这包括对错误设置函数的调用，如`PyErr_SetString`。"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:239 ./src/3rd/pybind11/pybind11_demo.md:1185
msgid "\"C API type error demo\""
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:241 ./src/3rd/pybind11/pybind11_demo.md:1187
msgid "// But it would be easier to simply...\n"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:243 ./src/3rd/pybind11/pybind11_demo.md:1189
msgid "\"pybind11 wrapper type error\""
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:246 ./src/3rd/pybind11/pybind11_demo.md:1192
msgid "也可以调用`PyErr_Clear`来忽略错误。"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:248 ./src/3rd/pybind11/pybind11_demo.md:1194
msgid "任何Python错误必须被抛出或清除，否则Python/pybind11将处于无效的状态。"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:250
msgid "9.6 异常链（raise from）"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:252
msgid "在Python 3.3中，引入了指示异常是由其他异常引发的机制："
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:258 ./src/3rd/pybind11/09.异常.md:267
msgid "\"could not divide by zero\""
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:261
msgid ""
"pybind11 "
"2.8版本，你可以使用`py::raise_from`函数来完成相同的事。它设置当前Python错误指示器，所以要继续传播异常，你应该`throw "
"py::error_already_set()`（Python 3 only）。"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:265
msgid "\"print(1 / 0\""
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:272
msgid "9.7 处理unraiseable异常"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:274
msgid ""
"如果Python调用的C++析构函数或任何标记为`noexcept(true)`的函数抛出了异常，该异常不会传播出去。如果它们在调用图中抛出或捕捉不到任何异常，c++运行时将调用std::terminate()立即终止程序。"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:276 ./src/3rd/pybind11/pybind11_demo.md:1200
msgid ""
"类似的，在类`__del__`方法引发的Python异常也不会传播，但被Python作为unraisable错误记录下来。在Python "
"3.8+中，将触发system hook，并记录auditing event日志。"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:278 ./src/3rd/pybind11/pybind11_demo.md:1202
msgid ""
"任何noexcept函数应该使用try-catch代码块来捕获`error_already_set`（或其他可能出现的异常）。pybind11包装的Python异常并非真正的Python异常，它是pybind11捕获并转化的C++异常。noexcept函数不能传播这些异常。我们可以将它们转换为Python异常，然后丢弃`discard_as_unraisable`，如下所示。"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:285 ./src/3rd/pybind11/pybind11_demo.md:1209
msgid ""
"// Discard the Python error using Python APIs, using the C++ magic\n"
"        // variable __func__. Python already knows the type and value and of "
"the\n"
"        // exception object.\n"
msgstr ""

#: ./src/3rd/pybind11/09.异常.md:290 ./src/3rd/pybind11/pybind11_demo.md:1214
msgid "// Log and discard C++ exceptions.\n"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:58
msgid "10. 智能指针"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:60
msgid "10.1 `std::unique_ptr`"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:62
msgid "给定一个带Python绑定的类`Example`，我们可以像下面一样返回它的unique pointer智能指针实例："
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:67
msgid "\"create_example\""
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:70
msgid ""
"没其他需要特殊处理的地方。需要注意的是，虽然允许返回unique_ptr对象，但是将其作为函数入参是非法的。例如，pybind11不能处理下列函数签名。"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:76
msgid "上面的签名意味着Python需要放弃对象的所有权，并将其传递给该函数，这通常是不可能的（对象可能在别处被引用）。"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:78
msgid "10.2 `std::shared_ptr`"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:80
msgid ""
"`class_`可以传递一个表示持有者类型的模板类型，它用于管理对象的引用。在不指定的情况下，默认为`std::unique_ptr<Type>`类型，这意味着当Python的引用计数为0时，将析构对象。该模板类型可以指定为其他的智能指针或引用计数包装类，像下面我们就使用了`std::shared_ptr`："
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:83
msgid "/* <- holder type */"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:86
msgid "注意，每个类仅能与一个持有者类型关联。"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:88
msgid "使用持有者类型的一个潜在的障碍就是，你需要始终如一的使用它们。猜猜下面的绑定代码有什么问题？"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:96
msgid "/* Hint: ** DON'T DO THIS ** */"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:102
msgid "\"Child\""
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:104
msgid "\"Parent\""
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:106
msgid "\"get_child\""
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:110
msgid "下面的Python代码将导致未定义行为（类似段错误）。"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:117
msgid ""
"问题在于`Parent::get_child()`返回类`Child`实例的指针，但事实上这个经由`std::shared_ptr<...>`管理的实例，在传递原始指针时就丢失了。这个例子中，pybind11将创建第二个独立的`std::shared_ptr<...>`声明指针的所有权。最后，对象将被free两次，因为两个shared指针没法知道彼此的存在。"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:119
msgid "有两种方法解决这个问题："
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:121
msgid ""
"对于智能指针管理的类型，永远不要在函数如参数或返回值中使用原始指针。换句话说，在任何需要使用该类型指针的地方，使用它们指定的持有者类型代替。这个例子中`get_child()`可以这样修改："
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:127
msgid ""
"定义`Child`时指定`std::enable_shared_from_this<T>`作为基类。这将在`Child`的基础上增加一点信息，让pybind11认识到这里已经存在一个`std::shared_ptr<...>`，并与之交互。修改示例如下："
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:133
msgid "10.3 自定义智能指针"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:135
msgid ""
"pybind11支持开箱即用的 `std::unique_ptr` 和 `std::shared_ptr` "
"。对于其他自定义的智能指针，可以使用下面的宏使能透明转换（transparent conversions）。它必须在其他绑定代码之前在顶层名称空间中声明："
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:141
msgid "宏的第一个参数为占位符名称，用作第二个参数的模板参数。因此，你可以使用任意的标识符（不要使用你的代码中已经存在的类型），只需保持两边一致即可。"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:143
msgid "宏也可以接收第三个可选的bool类型参数，默认为false。"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:149
msgid ""
"如果`SmartPtr<T>`总是从`T*`指针初始化，不存在不一致的风险（如多个独立的`SmartPtr<T>`认为他们是`T*`指针的唯一拥有者）。当`T`实例使用侵入式引用计数时，应设定为`true`。"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:151
msgid ""
"在使用该特性前，请先阅读 [General notes regarding convenience "
"macros](https://pybind11.readthedocs.io/en/stable/advanced/misc.html#macro-notes)。"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:153
msgid ""
"默认情况下，pybind11假定自定义智能指针具有标准接口，如提供`.get()`成员函数来获取底层的原始指针。如果没有，则需要指定`holder_helper`："
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:156
msgid "// Always needed for custom holder types\n"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:158
msgid "// Only needed if the type's `.get()` goes by another name\n"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:162
msgid "// <-- specialization\n"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:168
msgid "上述特化告诉pybind11，自定义`SmartPtr`通过`.getPointer()`提供`.get()`接口。"
msgstr ""

#: ./src/3rd/pybind11/10.智能指针.md:170
msgid "see also: 文件`tests/test_smart_ptr.cpp`提供了一个展示如何使用自定义引用计数holder类型的详细示例。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:58
msgid "11. 类型转换"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:60
msgid ""
"除了支持跨语言函数调用，pybind11这类绑定工具必须处理的一个基本问题就是，提供在C++中访问原生Python类型的方式，反之亦然。有三种完全不同的方法做到这点，每种方法适用性取决于你使用的环境。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:62
msgid "任意侧使用原生的C++类型。这种情况下，必须使用pybind11生成类型的绑定，Python才能使用它。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:63
msgid "任意侧使用原生的Python类型。同样需要包装后，C++函数才能够使用它。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:64
msgid ""
"C++侧使用原生C++类型，Python侧使用原生Python类型。pybind11称其为类型转换。 "
"某种意义下，在任意侧使用原生类型，类型转换是最自然的选项。该方法主要的缺点是，每次Python和C++之间转换时都需要拷贝一份数据，因为C++和Python的对相同类型的内存布局不一样。 "
"pybind11可以自动完成多种类型的转换。后面会提供所有内置转换的表格。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:68
msgid "下面的小节将更详细地讨论这些选项之间的区别。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:70
msgid "11.1 概述"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:72
msgid "**1. Native type in C++, wrapper in Python**"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:74
msgid ""
"在“面对对象编程”一章中，我们详细介绍了通过`py::class_`公开自定义C++类型的方法。这里，底层的数据结构仍然是原始的C++类，而`py::class_`包装则提供了Python侧的接口。当一个对象从C++侧发送到Python侧时，pybind11仅仅在原始的C++对象上增加了一层包装而已。从Python侧获取它也仅仅是撕掉了包装而已。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:76
msgid "**2. Wrapper in C++, native type in Python**"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:78
msgid ""
"这与上面是完全相反的情况。现在我们有一个原生的Python类型，如tuple或list。在C++侧获取这个数据的一种方法是使用`py::object`族包装器。这将在后续章节详细解释。这里举个简单的例子："
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:92
msgid ""
"Python的list仅仅是包裹在了C++ "
"`py::list`类里，并没有仅仅任何转换。它的核心任然是一个Python对象。拷贝一个`py::list`会像Python中一样增加引用计数。将对象返回到Python侧，将去掉这层封装。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:94
msgid "**3. Converting between native C++ and Python types**"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:96
msgid "前面两种情况，我们在一种语言中使用原生类型，而在另一种语言中使用它的包装类型。现在，我们在两侧都使用原生类型，并对他们进行类型转换。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:101
msgid "\"\\n\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:110
msgid ""
"这个例子中，pybind11将创建一个`std::vector<int>`实例，并从Python "
"list中拷贝每个元素。然后将该实例传递给`print_vector`。同样的事情发生在另一个方向：新建了一个list，并从C++的vector中获取元素值。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:112
msgid ""
"如下表所示，多数转换是开箱即用的。他们相当方便，但请记住一点，这些转换是基于数据拷贝的。这对小型的不变的类型相当友好，对于大型数据结构则相当昂贵。这可以通过自定义包装类型重载自动转换来规避（如上面提到的方法1）。This "
"requires some manual effort and more details are available in the [Making "
"opaque "
"types](https://pybind11.readthedocs.io/en/stable/advanced/cast/stl.html#opaque) "
"section."
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:114
msgid "**内置转换的列表**"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:116
msgid "下面基础数据类型是开箱即用的（有些可能需要include额外的头文件）。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:118
msgid "Data type"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:118
msgid "Description"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:118
msgid "Header file"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:120
msgid "`int8_t`, `uint8_t`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:120
msgid "8-bit integers"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:120 ./src/3rd/pybind11/11.类型转换.md:121
#: ./src/3rd/pybind11/11.类型转换.md:122 ./src/3rd/pybind11/11.类型转换.md:123
#: ./src/3rd/pybind11/11.类型转换.md:124 ./src/3rd/pybind11/11.类型转换.md:125
#: ./src/3rd/pybind11/11.类型转换.md:126 ./src/3rd/pybind11/11.类型转换.md:127
#: ./src/3rd/pybind11/11.类型转换.md:128 ./src/3rd/pybind11/11.类型转换.md:129
#: ./src/3rd/pybind11/11.类型转换.md:130 ./src/3rd/pybind11/11.类型转换.md:131
#: ./src/3rd/pybind11/11.类型转换.md:132 ./src/3rd/pybind11/11.类型转换.md:133
#: ./src/3rd/pybind11/11.类型转换.md:134 ./src/3rd/pybind11/11.类型转换.md:135
#: ./src/3rd/pybind11/11.类型转换.md:136 ./src/3rd/pybind11/11.类型转换.md:137
#: ./src/3rd/pybind11/11.类型转换.md:138 ./src/3rd/pybind11/11.类型转换.md:139
#: ./src/3rd/pybind11/11.类型转换.md:140 ./src/3rd/pybind11/11.类型转换.md:141
#: ./src/3rd/pybind11/11.类型转换.md:142
msgid "`pybind11/pybind11.h`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:121
msgid "`int16_t`, `uint16_t`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:121
msgid "16-bit integers"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:122
msgid "`int32_t`, `uint32_t`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:122
msgid "32-bit integers"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:123
msgid "`int64_t`, `uint64_t`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:123
msgid "64-bit integers"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:124
msgid "`ssize_t`, `size_t`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:124
msgid "Platform-dependent size"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:125
msgid "`float`, `double`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:125
msgid "Floating point types"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:126
msgid "`bool`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:126
msgid "Two-state Boolean type"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:127
msgid "`char`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:127
msgid "Character literal"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:128
msgid "`char16_t`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:128
msgid "UTF-16 character literal"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:129
msgid "`char32_t`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:129
msgid "UTF-32 character literal"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:130
msgid "`wchar_t`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:130
msgid "Wide character literal"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:131
msgid "`const char *`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:131
msgid "UTF-8 string literal"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:132
msgid "`const char16_t *`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:132
msgid "UTF-16 string literal"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:133
msgid "`const char32_t *`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:133
msgid "UTF-32 string literal"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:134
msgid "`const wchar_t *`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:134
msgid "Wide string literal"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:135
msgid "`std::string`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:135
msgid "STL dynamic UTF-8 string"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:136
msgid "`std::u16string`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:136
msgid "STL dynamic UTF-16 string"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:137
msgid "`std::u32string`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:137
msgid "STL dynamic UTF-32 string"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:138
msgid "`std::wstring`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:138
msgid "STL dynamic wide string"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:139
msgid "`std::string_view`, `std::u16string_view`, etc."
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:139
msgid "STL C++17 string views"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:140
msgid "`std::pair<T1, T2>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:140
msgid "Pair of two custom types"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:141
msgid "`std::tuple<...>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:141
msgid "Arbitrary tuple of types"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:142
msgid "`std::reference_wrapper<...>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:142
msgid "Reference type wrapper"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:143
msgid "`std::complex<T>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:143
msgid "Complex numbers"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:143
msgid "`pybind11/complex.h`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:144
msgid "`std::array<T, Size>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:144
msgid "STL static array"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:144 ./src/3rd/pybind11/11.类型转换.md:145
#: ./src/3rd/pybind11/11.类型转换.md:146 ./src/3rd/pybind11/11.类型转换.md:147
#: ./src/3rd/pybind11/11.类型转换.md:148 ./src/3rd/pybind11/11.类型转换.md:149
#: ./src/3rd/pybind11/11.类型转换.md:150 ./src/3rd/pybind11/11.类型转换.md:151
#: ./src/3rd/pybind11/11.类型转换.md:152 ./src/3rd/pybind11/11.类型转换.md:153
#: ./src/3rd/pybind11/11.类型转换.md:154 ./src/3rd/pybind11/11.类型转换.md:155
#: ./src/3rd/pybind11/11.类型转换.md:156
msgid "`pybind11/stl.h`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:145
msgid "`std::vector<T>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:145
msgid "STL dynamic array"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:146
msgid "`std::deque<T>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:146
msgid "STL double-ended queue"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:147
msgid "`std::valarray<T>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:147
msgid "STL value array"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:148
msgid "`std::list<T>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:148
msgid "STL linked list"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:149
msgid "`std::map<T1, T2>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:149
msgid "STL ordered map"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:150
msgid "`std::unordered_map<T1, T2>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:150
msgid "STL unordered map"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:151
msgid "`std::set<T>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:151
msgid "STL ordered set"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:152
msgid "`std::unordered_set<T>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:152
msgid "STL unordered set"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:153
msgid "`std::optional<T>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:153
msgid "STL optional type (C++17)"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:154
msgid "`std::experimental::optional<T>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:154
msgid "STL optional type (exp.)"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:155
msgid "`std::variant<...>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:155
msgid "Type-safe union (C++17)"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:156
msgid "`std::filesystem::path<T>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:156
msgid ""
"STL path (C++17) "
"[1](https://pybind11.readthedocs.io/en/stable/advanced/cast/overview.html#id2)"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:157
msgid "`std::function<...>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:157
msgid "STL polymorphic function"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:157
msgid "`pybind11/functional.h`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:158
msgid "`std::chrono::duration<...>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:158
msgid "STL time duration"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:158 ./src/3rd/pybind11/11.类型转换.md:159
msgid "`pybind11/chrono.h`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:159
msgid "`std::chrono::time_point<...>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:159
msgid "STL date/time"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:160
msgid "`Eigen::Matrix<...>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:160
msgid "Eigen: dense matrix"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:160 ./src/3rd/pybind11/11.类型转换.md:161
#: ./src/3rd/pybind11/11.类型转换.md:162
msgid "`pybind11/eigen.h`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:161
msgid "`Eigen::Map<...>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:161
msgid "Eigen: mapped memory"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:162
msgid "`Eigen::SparseMatrix<...>`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:162
msgid "Eigen: sparse matrix"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:164
msgid "11.2 Strings, bytes and Unicode conversions"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:166
msgid ""
"Note: 本节讨论的string处理基于Python3 "
"strings。对于python2.7，使用`unicode`替换`str`，`str`替换`bytes`。Python2.7用于最好使用`from "
"__future__ import unicode_literals`避免无意间使用`str`代替`unicode`。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:168
msgid "11.2.1 传递Python strings到C++"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:170
msgid ""
"当向一个接收`std::string`或`char "
"*`参数的函数传递Python的`str`时，pybind11会将Python字符串编码为UTF-8。所有的Python "
"`str`都能够用UTF-8编码，所以这个操作不会失败。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:172
msgid "C++语言是encoding agnostic。程序员负责处理编码，最简单的做法就是每处都使用UTF-8。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:175
msgid "\"utf8_test\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:177
msgid "\"utf-8 is icing on the cake.\\n\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:181
msgid "\"utf8_charptr\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:183
msgid "\"My favorite food is\\n\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:190
msgid "\"🎂\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:194
msgid "\"🍕\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:199
msgid "Note: 有些终端模拟器不支持UTF-8或emoji字体，上面的例子可能无法显示。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:201
msgid "无论C++函数的参数是传值或引用，是否是const，结果都是一样的。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:203
msgid "**向C++传递bytes对象**"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:205
msgid ""
"向接收`std::string`或`char *`类型参数的C++函数传递Python "
"bytes对象无需转换。在Python3上，如果想要函数只接收bytes，不接收str，可以声明参数类型为`py::bytes`。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:207
msgid "11.2.2 向Python返回C++ 字符串"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:209
msgid ""
"当C++函数返回`std::string`或`char*`参数给Python调用者时，pybind11会将字符串以UTF-8格式解码给原生Python "
"str，类似于Python中的`bytes.decode('utf-8')`。如果隐式转换失败，pybind11将会抛出异常`UnicodeDecodeError`。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:212
msgid "\"std_string_return\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:214
msgid "\"This string needs to be UTF-8 encoded\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:224
msgid "因为UTF-8包含纯ASCII，返回一个纯ASCII字符串到Python没有任何问题。否则就需要确保编码是有效的UTF-8。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:226
msgid "Warning: 隐式转换假定`char *`字符串以null为结束符。若不是，将导致缓冲区溢出。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:228
msgid "**显式转换**"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:230
msgid "如果C++代码构造了一个非UTF-8的string字符串，可以执行显式转换并返回`py::str`对象。显式转换与隐式转换的开销相同。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:233
msgid "// This uses the Python C API to convert Latin-1 to Unicode\n"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:234
msgid "\"str_output\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:236
msgid "\"Send your r\\xe9sum\\xe9 to Alice in HR\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:236
msgid "// Latin-1\n"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:244
msgid "'Send your résumé to Alice in HR'"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:248
msgid ""
"[Python C "
"API](https://docs.python.org/3/c-api/unicode.html#built-in-codecs)提供了一些内置的编解码方法可以使用。也可以使用第三方库如libiconv "
"来转换UTF-8。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:250
msgid "**不使用类型转换来返回C++字符串**"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:252
msgid ""
"如果C++ `std::string`中的数据不表示文本，则应该以`bytes`的形式传递给Python，这时我们可以返回一个`py::btyes`对象。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:255
msgid "\"return_bytes\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:257 ./src/3rd/pybind11/11.类型转换.md:282
msgid "\"\\xba\\xd0\\xba\\xd0\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:257
msgid "// Not valid UTF-8\n"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:258
msgid "// Return the data without transcoding\n"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:265
msgid "'\\xba\\xd0\\xba\\xd0'"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:268
msgid "注意：pybind11可以将bytes无需编码地转换为`std::string`，但不能不经编码地隐式转换`std::string`到bytes。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:271
msgid "\"asymmetry\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:272
msgid "// Accepts str or bytes from Python\n"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:273
msgid "// Looks harmless, but implicitly converts to str\n"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:279
msgid "\"have some bytes\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:282
msgid "# invalid utf-8 as bytes\n"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:283
msgid "'utf-8'"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:283
msgid "'t decode byte 0xba in position 0: invalid start byte\n"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:286
msgid "11.2.3 宽字符串"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:288
msgid ""
"向入参为`std::wstring`、`wchar_t*`、`std::u16string`或`std::u32string`的C++函数传递Python "
"str对象，str将被编码为UTF-16或UTF-32（具体哪种取决于C++编译器的支持）。当C++函数返回这些类型的字符串到Python "
"str时，需要保证字符串是合法的UTF-16或UTF-32。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:292
msgid "<windows.h>"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:294
msgid "\"set_window_text\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:296
msgid "// Call SetWindowText with null-terminated UTF-16 string\n"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:300
msgid "\"get_window_text\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:309
msgid "// wstring will be converted to Python str\n"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:315
msgid "警告：带`--enable-unicode=ucs2`选项编译的Python 2.7和3.3版本可能不支持上述的宽字符串。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:317
msgid "多字节编码地字符串，如Shift-JIS，必须转换为UTF-8/16/32后，再返回给Python。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:319
msgid "11.2.4 字符类型"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:321
msgid ""
"向一个入参为字符类型（char, wchar_t）的C++函数，传递Python "
"str，C++函数将接收str的首字符。如果字符串超过一个Unicode字符长度，将忽略尾部字节。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:323
msgid "当C++返回一个字符变量时，它将被转化为单字符的str变量。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:326
msgid "\"pass_char\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:327
msgid "\"pass_wchar\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:331 ./src/3rd/pybind11/11.类型转换.md:341
msgid "'A'"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:335
msgid ""
"虽然C++可以将整数转换为字符类型（`char c = "
"0x65`），pybind11并不会隐式转换Python整数到字符类型。可以使用`chr()`Python函数来将整数转换为字符。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:345
msgid "如果需要使用8-bit整数，可使用`int8_t`或`uint8_t`作为参数类型。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:347
msgid "11.2.5 Grapheme clusters"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:349
msgid ""
"A single grapheme may be represented by two or more Unicode characters. For "
"example ‘é’ is usually represented as U+00E9 but can also be expressed as "
"the combining character sequence U+0065 U+0301 (that is, the letter ‘e’ "
"followed by a combining acute accent). The combining character will be lost "
"if the two-character sequence is passed as an argument, even though it "
"renders as a single grapheme."
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:351
msgid ""
"```\n"
">>> example.pass_wchar(\"é\")\n"
"'é'\n"
"\n"
">>> combining_e_acute = \"e\" + \"\\u0301\"\n"
"\n"
">>> combining_e_acute\n"
"'é'\n"
"\n"
">>> combining_e_acute == \"é\"\n"
"False\n"
"\n"
">>> example.pass_wchar(combining_e_acute)\n"
"'e'\n"
"```"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:367
msgid ""
"Normalizing combining characters before passing the character literal to C++ "
"may resolve _some_ of these issues:"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:369
msgid ""
"```\n"
">>> example.pass_wchar(unicodedata.normalize(\"NFC\", combining_e_acute))\n"
"'é'\n"
"```"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:374
msgid ""
"In some languages (Thai for example), there are [graphemes that cannot be "
"expressed as a single Unicode code "
"point](http://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries), so "
"there is no way to capture them in a C++ character type."
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:376
msgid "11.2.6 c++17 string_view"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:378
msgid ""
"C++17 string views are automatically supported when compiling in C++17 mode. "
"They follow the same rules for encoding and decoding as the corresponding "
"STL string type (for example, a `std::u16string_view` argument will be "
"passed UTF-16-encoded data, and a returned `std::string_view` will be "
"decoded as UTF-8)."
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:380
msgid "11.3 STL容器"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:382
msgid "11.3.1 自动转换"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:384
msgid ""
"包含头文件`pybind11/stl.h`后，自动支持 "
"`std::vector<>`/`std::deque<>`/`std::list<>`/`std::array<>`/`std::valarray<>`, "
"`std::set<>`/`std::unordered_set<>`, 和`std::map<>`/`std::unordered_map<>` "
"到Python `list`, `set` 和 `dict` 的类型转换。 `std::pair<>` 和`std::tuple<>` "
"类型转换在`pybind11/pybind11.h`中已经支持。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:386
msgid "隐式转换的主要缺点就是Python和C++之间的容器类型转换都需要拷贝数据，这对程序语义和性能有一定的影响。后续章节将介绍如何避免该问题。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:388
msgid "Note: 这些类型任意嵌套都是可以的。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:390
msgid "11.3.2 C++17库的容器"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:392
msgid ""
"`pybind11/stl.h`支持C++17的 `std::optional<>` "
"和`std::variant<>`，C++14的`std::experimental::optional<>`。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:394
msgid "C++11中也存在这些容器的其他版本，如Boost中。pybind11提供了一个简单的方法`type_caster`来处理这些类型："
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:397
msgid ""
"// `boost::optional` as an example -- can be any `std::optional`-like "
"container\n"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:404
msgid ""
"上述内容应放到头文件中，并在需要的地方包含它们。Similarly, a specialization can be provided for "
"custom variant types:"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:407
msgid ""
"// `boost::variant` as an example -- can be any `std::variant`-like "
"container\n"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:412
msgid ""
"// Specifies the function used to visit the variant -- `apply_visitor` "
"instead of `visit`\n"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:420 ./src/3rd/pybind11/11.类型转换.md:701
msgid "// namespace pybind11::detail\n"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:423
msgid ""
"The `visit_helper` specialization is not required if your `name::variant` "
"provides a `name::visit()` function. For any other function name, the "
"specialization must be included to tell pybind11 how to visit the variant."
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:425
msgid ""
"Warning: When converting a `variant` type, pybind11 follows the same rules "
"as when determining which function overload to call ([Overload resolution "
"order](https://pybind11.readthedocs.io/en/stable/advanced/functions.html#overload-resolution)), "
"and so the same caveats hold. In particular, the order in which the "
"`variant`’s alternatives are listed is important, since pybind11 will try "
"conversions in this order. This means that, for example, when converting "
"`variant<int, bool>`, the `bool` variant will never be selected, as any "
"Python `bool` is already an `int` and is convertible to a C++ `int`. "
"Changing the order of alternatives (and using `variant<bool, int>`, in this "
"example) provides a solution."
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:427
msgid "11.3.3 制作opaque类型"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:429
msgid ""
"pybind11严重依赖于模板匹配机制来转换STL类型的参数和返回值，如vector，链表，哈希表等。甚至会递归处理，如lists of hash "
"maps of pairs of elementary and custom types。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:431
msgid "然而，这个方法的一个基本限制就是，Python和C++类型的转换涉及到拷贝操作，这妨碍了pass-by-reference的语义。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:433
msgid "假设我们绑定如下函数："
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:441
msgid "在Python中调用它："
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:450
msgid ""
"如你所见，通过引用传递STL数据时，修改并不会传递到Python侧。相同的场景表现在通过`def_readwrite`或`def_readonly`函数公开STL数据结构时："
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:463
msgid "\"contents\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:466
msgid "这个例子中，属性可以整体的读写。但是，涉及到append操作时就无能为力了："
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:478
msgid ""
"最后，在处理大型列表时，涉及的拷贝操作会耗费巨大。为处理上述场景，pybind11提供了`PYBIND11_MAKE_OPAQUE(T)`来禁用基于模板的类型转换机制，从而使他们变得不透明（_opaque_）。opaque对象的内容永远不会被检查或提取，因此它们可以通过引用传递。例如，要将`std::vector<int>`转换为opaque类型，需要在所有绑定代码之前添加声明："
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:484
msgid ""
"这个宏必须在顶层（所有命名空间外）设定，因为然添加了`type_caster`的模板实例化。如果你绑定代码包含多个编译单元，需要在每个文件使用`std::vector<int>`前指定（通常通过公共的头文件来实现）。opaque对象有相关的`class_`定义来联系Python中的类名，还需定义一组有用的操作，如："
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:487
msgid "\"IntVector\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:489
msgid "\"clear\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:490
msgid "\"pop_back\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:491
msgid "\"__len__\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:492
msgid "\"__iter__\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:494
msgid "/* Keep vector alive while iterator is used */"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:495
msgid "// ....\n"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:498
msgid "11.3.4 绑定STL容器"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:500
msgid ""
"公开STL容器作为一个Python对象时一个相当常见的需求，因此pybind11也提供了一个可选的头文件`pybind11/stl_bind.h`来做这件事。映射容器会尽可能的去匹配Python对应类型的行为。下面示例将展示该机制的使用方法："
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:503
msgid "// Don't forget this\n"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:504
msgid "<pybind11/stl_bind.h>"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:510
msgid "// later in binding code:\n"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:512 ./src/3rd/pybind11/11.类型转换.md:521
msgid "\"VectorInt\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:513
msgid "\"MapStringDouble\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:516
msgid ""
"绑定STL容器时，pybind11会根据容器元素的类型来决定该容器是否应该局限于模块内（参考Module-local class "
"bindings特性）。如果容器元素的类型不是已经绑定的自定义类型且未标识`py::module_local`，那么容器绑定将应用`py::module_local`。这包括数值类型、strings、Eigen类型，和其他在绑定STL容器时还未绑定的类型。module-local绑定的意图是为了避免模块间的潜在的冲突（如，两个独立的模块都试图绑定`std::vector<int>`）。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:518
msgid ""
"通过指定属性`py::module_local()`或`py_module_local(false)`，你也可以强制绑定的STL容器公开在模块内或全局："
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:524
msgid "注意：这样的全局绑定可能会导致模块无法加载，如果其他的模块也绑定了相同的容器类型（如`std::vector<int>`）并以加载。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:526
msgid "11.4 函数对象"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:528
msgid "要使能以下属性，需要包含`pybind11/functional.h`。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:530
msgid "**回调并传递匿名函数**"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:532
msgid ""
"C++11标准引入了功能强大的lambda函数和泛函对象`std::function<>`。lambda函数有两种类型：无状态lambda函数类似于指向一块匿名代码的函数指针，而有状态lambda函数还依赖于存储在lambda闭包对象中的被捕获的参数。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:534
msgid "这里有一个接收任意函数签名为`int -> int`的函数类型参数（有状态或无状态）："
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:542
msgid "下面的例子更复杂，它的入参是一个函数对象，并返回一个同样类型的函数对象。返回值是一个有状态的lambda函数，它捕获了`f`参数："
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:552
msgid "在C++回调函数中使用python具名参数，需要使用`py::cpp_function`包裹，类似于下面的代码："
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:557
#: ./src/3rd/pybind11/12.Python的C++接口.md:200
#: ./src/3rd/pybind11/13.内嵌解释器.md:120
#: ./src/3rd/pybind11/13.内嵌解释器.md:138
msgid "\"number\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:561
msgid "包含`pybind11/functional.h`头文件后，可以简单地直接为上述函数生成绑定代码："
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:564
msgid "<pybind11/functional.h>"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:567
msgid "\"func_arg\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:568
msgid "\"func_ret\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:569
msgid "\"func_cpp\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:573
msgid "Python中交互示例如下："
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:591
msgid "Warning"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:593
msgid ""
"请记住在从C++传递函数对象到Python的过程中（反向亦然），将生成一些包装代码来两种语言的函数调用。这种翻译自然会稍微增加函数调用的开销。当一个函数在Python和C++之间来回拷贝多次时，包装层数会不断累积，会明显降低性能。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:595
msgid ""
"这里有个例外：一个无状态函数作为参数传递给在Python中公开的另一个C++函数时，将不会有额外的开销。Pybind11将从封装的函数中提取C++函数指针，以回避潜在地C++ "
"-> Python -> C++的往返。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:597
msgid "11.5 Chrono"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:599
msgid ""
"包含`pybind11/chrono`将使能C++11 chrono和Python datatime对象将的自动转换，还支持python "
"floats（从`time.monotonic()`或`time.perf_counter()`获取的）和`time.process_time()`到durations的转换。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:601
msgid "11.5.1 C++11时钟的概览"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:603
msgid ""
"使用这些转换时容易混淆的点是，C++11中提供的各种时钟的差异。C++11标准定义了三种时钟类型，用户也可以根据自身需求定义自己的时钟类型。这些时钟有着不用的属性，与Python之间转换时也会获得不同的结果。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:605
msgid ""
"标准定义的第一种时钟`std::chrono::system_clock`。它测量当前的时间和日期。但是，这个时钟会随着操作系统的时钟变化而改变。例如，在系统时间与时间服务器同步时，这个时钟也会跟着改变。这对计时功能来说很糟糕，但对测量wall "
"time还是有用的。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:607
msgid ""
"标准定义的第二种时钟`std::chrono::steady_clock`。这个时钟以稳定的速度跳动，从不调整。这非常实用于计时功能，但与实际时间和日志并不一致。这个时间通常是你操作系统已经运行的时间，虽然不是必须的。这个时钟永远不会与系统时钟相同，因为系统时钟可以改变，但steady_clock不能。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:609
msgid ""
"标准定义的第二种时钟`std::chrono::high_resolution_clock`。它是系统中分辨率最高的时钟，通常是system clock "
"或 steady "
"clock的一种，也可以有自己独立的时钟。需要注意的是，你在Python中获取到的该时钟的转换值，可能存在差异，这取决于系统的实现。如果它是系统时钟的一种，Python将得到datetime对象，否则将得到timedelta对象。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:611
msgid "11.5.2 提供的转换"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:613
msgid "**C++到Python**"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:615
msgid "`std::chrono::system_clock::time_point` → `datetime.datetime`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:616
msgid "`std::chrono::duration` → `datetime.timedelta`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:617
msgid "`std::chrono::[other_clocks]::time_point` → `datetime.timedelta`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:619
msgid "**Python到C++**"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:621
msgid ""
"`datetime.datetime`or`datetime.date`or`datetime.time` → "
"`std::chrono::system_clock::time_point`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:622
msgid "`datetime.timedelta` → `std::chrono::duration`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:623
msgid "`datetime.timedelta` → `std::chrono::[other_clocks]::time_point`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:624
msgid "`float` → `std::chrono::duration`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:625
msgid "`float` → `std::chrono::[other_clocks]::time_point`"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:627
msgid "11.6 Eigen"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:629
msgid "没接触过Eigen，先不翻译。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:631
msgid "11.7 自定义类型转换"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:633
msgid ""
"在极少数情况下，程序可能需要一些pybind11没有提供的自定义类型转换，这需要使用到原始的Python C "
"API。这是相当高级的使用方法，只有熟悉Python引用计数复杂之处的专家才能使用。"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:635
msgid ""
"The following snippets demonstrate how this works for a very simple `inty` "
"type that that should be convertible from Python types that provide a "
"`__int__(self)` method."
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:645
msgid ""
"The following Python snippet demonstrates the intended usage from the Python "
"side:"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:658
msgid ""
"To register the necessary conversion routines, it is necessary to add an "
"instantiation of the `pybind11::detail::type_caster<T>` template. Although "
"this is an implementation detail, adding an instantiation of this type is "
"explicitly allowed."
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:664
msgid ""
"/**\n"
"         * This macro establishes the name 'inty' in\n"
"         * function signatures and declares a local variable\n"
"         * 'value' of type inty\n"
"         */"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:669
msgid "\"inty\""
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:671
msgid ""
"/**\n"
"         * Conversion part 1 (Python->C++): convert a PyObject into a inty\n"
"         * instance or return false upon failure. The second argument\n"
"         * indicates whether implicit conversions should be applied.\n"
"         */"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:677
msgid "/* Extract PyObject from handle */"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:679
msgid "/* Try converting into a Python integer value */"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:683
msgid "/* Now try to convert into a C++ int */"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:686
msgid "/* Ensure return code was OK (to avoid out-of-range errors etc) */"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:690
msgid ""
"/**\n"
"         * Conversion part 2 (C++ -> Python): convert an inty instance into\n"
"         * a Python object. The second and third arguments are used to\n"
"         * indicate the return value policy and parent object (for\n"
"         * ``return_value_policy::reference_internal``) and are generally\n"
"         * ignored by implicit casters.\n"
"         */"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:697
msgid "/* policy */"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:697
msgid "/* parent */"
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:704
msgid ""
"Note: A `type_caster<T>` defined with `PYBIND11_TYPE_CASTER(T, ...)` "
"requires that `T` is default-constructible (`value` is first default "
"constructed and then `load()` assigns to it)."
msgstr ""

#: ./src/3rd/pybind11/11.类型转换.md:706
msgid ""
"Warning: When using custom type casters, it’s important to declare them "
"consistently in every compilation unit of the Python extension module. "
"Otherwise, undefined behavior can ensue."
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:58
msgid "12. Python C++接口"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:60
msgid ""
"pybind11通过简单的C++包装公开了Python类型和函数，这使得我们可以方便的在C++中调用Python代码，而无需借助Python C API。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:62
msgid "12.1 Python类型"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:64
msgid "12.1.1 可用的封装"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:66
msgid ""
"所有主要的Python类型通过简单C++类封装公开出来了，可以当做参数参数来使用。包括： `handle`, `object`, `bool_`, "
"`int_`, `float_`, `str`, `bytes`, `tuple`, `list`, `dict`, `slice`, `none`, "
"`capsule`, `iterable`, `iterator`, `function`, `buffer`, `array`, 和`array_t`."
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:68
msgid ""
"Warning: Be sure to review the "
"[Gotchas](https://pybind11.readthedocs.io/en/stable/advanced/pycpp/object.html#pytypes-gotchas) "
"before using this heavily in your C++ API."
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:70
msgid "12.1.2 在C++中实例化复合Python类型"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:72
msgid "字典对象可以通过`dict`构造函数来初始化："
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:75
#: ./src/3rd/pybind11/12.Python的C++接口.md:90
#: ./src/3rd/pybind11/12.Python的C++接口.md:186
msgid "// to bring in the `_a` literal\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:76
#: ./src/3rd/pybind11/12.Python的C++接口.md:82
#: ./src/3rd/pybind11/12.Python的C++接口.md:92
msgid "\"spam\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:76
#: ./src/3rd/pybind11/12.Python的C++接口.md:92
msgid "\"eggs\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:79
msgid "tuple对象可以通过`py::make_tuple()`来构造："
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:85
msgid "每个元素都会被转换为支持的Python类型，"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:87
msgid "simple namespace可以这样实例化："
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:91
msgid "\"types\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:91
msgid "\"SimpleNamespace\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:95
msgid ""
"namespace的属性可以通过`py::delattr()`，`py::getattr()`和`py::setattr()`来修改。Simple "
"namespaces可以作为类实例的轻量级替代。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:97
msgid "12.1.3 相互转换"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:99
msgid "混合编程时，通常需要将任意C++类型转换为Python类型，可以使用`py::cast()`来实现："
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:106
msgid "反方向可以使用以下语法："
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:113
msgid "转换失败时，两个方向都会抛出`cast_error`异常。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:115
msgid "12.1.4 在C++中访问Python库"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:117
msgid "在C++中也可以导入Python标准库或Python环境（sys.path)可找到的库的对象。示例如下："
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:120
msgid "// Equivalent to \"from decimal import Decimal\"\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:121
msgid "\"decimal\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:121
msgid "\"Decimal\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:122
msgid "// Try to import scipy\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:124
msgid "\"scipy\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:125
msgid "\"__version__\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:128
msgid "12.1.5 调用Python函数"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:130
msgid "通过`operator()`可以调用Python类、函数和方法。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:133
msgid "// Construct a Python object of class Decimal\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:134
msgid "\"3.14159\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:135
msgid "// Use Python to make our directories\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:137
#: ./src/3rd/pybind11/12.Python的C++接口.md:225
msgid "\"os\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:138
msgid "\"makedirs\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:139
msgid "\"/tmp/path/to/somewhere\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:142
msgid ""
"One can convert the result obtained from Python to a pure C++ version if a "
"`py::class_` or type conversion is defined."
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:150
msgid "12.1.6 调用Python对象的方法"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:152
msgid "使用`.attr`可以调用对象的Python方法。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:155
msgid "// Calculate e^π in decimal\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:156
#: ./src/3rd/pybind11/12.Python的C++接口.md:163
msgid "\"exp\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:160
msgid ""
"In the example above `pi.attr(\"exp\")` is a _bound method_: it will always "
"call the method for that same instance of the class. Alternately one can "
"create an _unbound method_ via the Python class (instead of instance) and "
"pass the `self` object explicitly, followed by other arguments."
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:164
msgid "// Compute the e^n for n=0..4\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:171
msgid "12.1.7 关键字参数"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:173
msgid "支持关键字参数，Python语法示例如下："
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:177
msgid "# function code\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:180
msgid "# keyword call in Python\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:183
msgid "C++中则可以这样写："
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:187
#: ./src/3rd/pybind11/12.Python的C++接口.md:200
#: ./src/3rd/pybind11/12.Python的C++接口.md:206
msgid "\"say\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:187
#: ./src/3rd/pybind11/12.Python的C++接口.md:200
#: ./src/3rd/pybind11/12.Python的C++接口.md:205
msgid "\"to\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:187
msgid "// keyword call in C++\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:190
msgid "12.1.8 拆包参数"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:192
msgid "拆包参数`*args`和`**kwargs`可以与其他参数混合使用："
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:195
msgid "// * unpacking\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:198
msgid "// ** unpacking\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:202
msgid "// mixed keywords, * and ** unpacking\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:209
msgid ""
"Generalized unpacking according to "
"[PEP448](https://www.python.org/dev/peps/pep-0448/) is also supported:"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:211
msgid ""
"```\n"
"py::dict kwargs1 = py::dict(\"number\"_a=1234);\n"
"py::dict kwargs2 = py::dict(\"to\"_a=some_instance);\n"
"f(**kwargs1, \"say\"_a=\"hello\", **kwargs2);\n"
"```"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:217
msgid "12.1.9 隐式转换"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:219
msgid ""
"当使用涉及Python类型的C++接口，或调用Python函数，返回`object`类型的对象时，会涉及到子类（如dict）的隐式转换。通过`operator[]`或`obj.attr()`返回代理对象也是如此。转型到子类可以提供代码的可读性，并允许向需要特定子类类型而不是通用`object`类型的C++函数传值。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:222
#: ./src/3rd/pybind11/12.Python的C++接口.md:452
msgid "<pybind11/numpy.h>"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:226
msgid "\"os.path\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:226
msgid "// like 'import os.path as path'\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:227
msgid "\"numpy\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:227
msgid "// like 'import numpy as np'\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:229
msgid "\"abspath\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:229
msgid "\"curdir\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:230
msgid "\"Current directory: \""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:231
msgid "\"environ\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:232
msgid "\"HOME\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:233
msgid "\"ones\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:233
msgid "\"dtype\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:233
msgid "\"float32\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:237
msgid "对`object`子类的隐式转型，不需要向自定义类那样显式调用`obj.cast()`。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:239
#: ./src/3rd/pybind11/12.Python的C++接口.md:444
msgid "**Note**"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:241
msgid ""
"If a trivial conversion via move constructor is not possible, both implicit "
"and explicit casting (calling `obj.cast()`) will attempt a “rich” "
"conversion. For instance, `py::list env = os.attr(\"environ\");` will "
"succeed and is equivalent to the Python code `env = list(os.environ)` that "
"produces a list of the dict keys."
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:243
msgid "12.1.10 处理异常"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:245
msgid "Python异常将会包装为`py::error_already_set`后抛出。详见前面的章节“在C++中处理Python异常”。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:247
msgid "12.1.11 Gotchas"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:249
msgid "**Default-Constructed Wrappers**"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:251
msgid ""
"通过包装类型的默认构造函数，不能得到有效的Python对象（不是`py::none`），和`PyObject*`空指针一样。可以通过`static_cast<bool>(my_wrapper)`来检查。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:253
msgid "**Assigning py::none() to wrappers**"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:255
msgid ""
"你可能想在C++函数中使用类似`py::str`和`py::dict`类型的参数，并给它们`py::none`默认值。但是，最好的情况是它会因为`None`无法转型为该类型而失败；最坏的情况是它会默默工作但会破坏你想要的类型（如Python中`py::str(py::none)`会返回None）。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:257
msgid "12.2 NumPy"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:259
msgid "12.2.1 缓冲协议（buffer protocol）"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:261
msgid ""
"Python支持插件库间以一种极其通用且便利方式进行数据交换。类型可以公开缓冲区视图，以提供对内部原始数据进行快速直接访问。假设我们想绑定下面的简单的Matrix类："
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:278
msgid ""
"下面的绑定代码将Matrix作为一个buffer对象公开，使得Matrices可以转型为NumPy "
"arrays。甚至可以完全避免拷贝操作，类似python语句`np.array(matrix_instance, copy = False)`。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:281
#: ./src/3rd/pybind11/12.Python的C++接口.md:317
msgid "\"Matrix\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:284
#: ./src/3rd/pybind11/12.Python的C++接口.md:347
msgid "/* Pointer to buffer */"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:285
#: ./src/3rd/pybind11/12.Python的C++接口.md:348
msgid "/* Size of one scalar */"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:286
#: ./src/3rd/pybind11/12.Python的C++接口.md:349
msgid "/* Python struct-style format descriptor */"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:287
#: ./src/3rd/pybind11/12.Python的C++接口.md:350
msgid "/* Number of dimensions */"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:288
#: ./src/3rd/pybind11/12.Python的C++接口.md:351
msgid "/* Buffer dimensions */"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:289
#: ./src/3rd/pybind11/12.Python的C++接口.md:354
msgid "/* Strides (in bytes) for each index */"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:295
msgid ""
"要使新类型支持缓冲协议，需要在`py:class_`构造函数中指定`py::buffer_protocol()`的标识，并调用`def_buffer()`方法定义一个通过给定的matrix实例创建`py::buffer_info`描述对象。`py::buffer_info`的内容反映了Python缓冲协议的规范。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:308
msgid ""
"要想创建一个支持Python "
"buffer对象为参数的C++函数，可以简单实用`py::buffer`作为函数参数之一。buffer对象会存在多种配置，因此通常在需要在函数体中进行安全检查。下面的例子，将展示如果定义一个双精度类型的Eigen矩阵的自定义构造函数，支持从兼容buffer对象来初始化（如NumPy "
"matrix）。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:311
msgid "/* Bind MatrixXd (or some other Eigen type) to Python */"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:321
msgid "/* Request a buffer descriptor from Python */"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:324
msgid "/* Some sanity checks ... */"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:326
msgid "\"Incompatible format: expected a double array!\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:329
msgid "\"Incompatible buffer dimension!\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:342
msgid "作为参考，Eigen数据类型的`def_buffer()`方法类似于如下结构："
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:359
msgid "关于绑定Eigen类型更简单的方法(尽管有一些限制)，请参阅Eigen部分。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:361
msgid "12.2.2 Arrays"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:363
msgid ""
"将上述代码中的`py::buffer`替换为`py::array`，我们可以限制函数只接收NumPy "
"array（而不是任意满足缓冲协议的Python类型）。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:365
msgid ""
"在很多场合，我们希望函数只接受特定数据类型的NumPy "
"array，可以使用`py::array_t<T>`来实现。如下所示，函数需要一个双精度浮点类型的NumPy array。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:371
msgid ""
"当上面的函数被其他类型（如int）调用时，绑定代码将试图将输入转型为期望类型的NumPy "
"array。该特性需要包含`pybind11/numpy.h`头文件。该文件不依赖与NumPy的头文件，因此可以独立于NumPy编译。运行时需要NumPy版本大于1.7.0。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:373
msgid ""
"NumPy "
"array的数据并不保证密集排布；此外，数据条目可以以任意的行列跨度分隔。有时，我们需要函数仅接受C（行优先）或Fortran（列优先）次序的密集排布数组。这就需要指定第二个模板参数为`py::array::c_style`或`py::array::f_style`。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:379
msgid ""
"`py::array::forcecast`参数为第二个模板参数的默认值。它确保将不支持的参数转型为满足指定需要的数组，而不是试图匹配下一个函数重载。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:381
msgid "arrays有一些基于NumPy API的方法："
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:383
msgid "`.dtype()`返回数组元素的类型。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:384
msgid "`.strides()`返回数组strides的指针。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:385
msgid "`.squeeze()`从给定数组的形状中删除一维的条目。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:386
msgid "`.view(dtype)`返回指定dtype类型的数组视图。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:387
msgid "`.reshape({i, j, ...})`返回指定shape的数组视图。`.resize({})`也可以。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:388
msgid "`.index_at(i, j, ...)`获取数组指定所以的元素。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:390
msgid "还有几种获取引用的方法(如下所述)。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:392
msgid "12.2.3 结构体类型"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:394
msgid ""
"为了让`py::array_t`可以使用结构体类型，首先我们需要注册这个类型的内存布局。这可以通过`PYBIND11_NUMPY_DTYPE`宏来实现。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:413
msgid "/* now both A and B can be used as template arguments to py::array_t */"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:417
msgid ""
"结构体需要是由基础算术类型、`std::complex`，之前已经注册的子结构体类型，`arrays`这些类型组成。支持C++数组和`std::array`。虽然有静态断言来防止不支持结构体类型的注册，使用者仍需负责地只使用plain结构体，这样可以安全的操作原始内存，而不会范围不变量。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:419
msgid "12.2.4 向量化函数"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:421
msgid "假设我们想要将一个如下签名的函数绑定到Python，想让他既能接收常规参数，又能接收任意NumPy数组参数（向量、矩阵、多维数组）。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:427
msgid "包含`pybind11/numpy.h`后，这很好实现："
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:430
msgid "\"vectorized_func\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:433
msgid ""
"这样将对数组中每个元素调用函数进行处理。与`numpy.vectorize()`一类方案相比，该方案显著的优势是：元素处理的循环完全在c++端运行，编译器可以将其压缩成一个紧凑的、优化后的循环。函数函数值将返回NumPy "
"数组类型`numpy.dtype.float64`。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:442
msgid ""
"标量`z`将透明地复制4次。输入数组`x`和`y`将自动转型为正确的类型（从`numpy.dtype.int64`转到需要的`numpy.dtype.int32`和`numpy.dtype.float32`）。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:446
msgid "只有传值或常量引用的算术类型、复数、POD类型才能向量化，其他参数将原样传递。带右值引用参数的函数不能向量化。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:448
msgid ""
"如果计算太过复杂而无法对其进行量化，就需要手动创建和访问缓冲区内容。下面的代码展示了这该如何进行。(the code is somewhat "
"contrived, since it could have been done more simply using `vectorize`)."
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:460
msgid "\"Number of dimensions must be one\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:463
msgid "\"Input shapes must match\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:465
msgid "/* No pointer is passed, so NumPy will allocate the buffer */"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:481
msgid "\"add_arrays\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:481
msgid "\"Add two NumPy arrays\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:485
msgid "12.2.5 直接访问"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:487
msgid ""
"出于性能方面的考虑，尤其是处理大型数组时，我们通常希望直接访问数组元素（已确定索引有效），而不需要在每次访问时进行内部维数和边界检查。为了规避这些检查，`array`和`array_t<T>`模板类提供了不带检查的代理类`unchecked<N>`和`mutable_unchecked<N>`，其中`N`为数组所需的维数。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:490
msgid "\"sum_3d\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:491
msgid "// x must have ndim = 3; can be non-writeable\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:499
msgid "\"increment_3d\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:500
msgid "// Will throw if ndim != 3 or flags.writeable is false\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:508
msgid ""
"要从`array`对象获取代理，你必须同时制定数据类型和维数作为模板参数，如`auto r = "
"myarray.mutable_unchecked<float, 2>()`。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:510
msgid ""
"如果在编译时不知道维度的数量，则可以省略维度模板参数（像这样`arr_t.unchecked()`、`arr.unchecked<T>()`）。这同样可以工作，只是会导致代码优化较少而有略微新能损失。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:512
msgid ""
"注意，返回的代理类时直接引用array的数据，只在构造时读取shape, strides, writeable "
"flag。您必须确保所引用的数组在返回对象的持续时间内不会被销毁或reshape, typically by limiting the scope of "
"the returned instance."
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:514
msgid ""
"The returned proxy object supports some of the same methods as `py::array` "
"so that it can be used as a drop-in replacement for some existing, "
"index-checked uses of `py::array`:"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:516
msgid "`.ndim()` returns the number of dimensions"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:517
msgid ""
"`.data(1, 2, ...)` and `r.mutable_data(1, 2, ...)` returns a pointer to the "
"`const T` or `T` data, respectively, at the given indices. The latter is "
"only available to proxies obtained via `a.mutable_unchecked()`."
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:518
msgid "`.itemsize()` returns the size of an item in bytes, i.e. `sizeof(T)`."
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:519
msgid "`.ndim()` returns the number of dimensions."
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:520
msgid "`.shape(n)` returns the size of dimension `n`"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:521
msgid ""
"`.size()` returns the total number of elements (i.e. the product of the "
"shapes)."
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:522
msgid ""
"`.nbytes()` returns the number of bytes used by the referenced elements "
"(i.e. `itemsize()` times `size()`)."
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:524
msgid "12.2.6 省略号"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:526
msgid ""
"Python 3 provides a convenient `...` ellipsis notation that is often used to "
"slice multidimensional arrays. For instance, the following snippet extracts "
"the middle dimensions of a tensor with the first and last index set to zero. "
"In Python 2, the syntactic sugar `...` is not available, but the singleton "
"`Ellipsis` (of type `ellipsis`) can still be used directly."
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:529
msgid "# a NumPy array\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:533
msgid ""
"The function `py::ellipsis()` function can be used to perform the same "
"operation on the C++ side:"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:536
msgid "/* A NumPy array */"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:540
msgid "12.2.7 内存视图"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:542
msgid ""
"当我们只想提供C/C++ buffer的访问接口而不用构造类对象时，我们可以返回一个`memoryview`对象。假设我们希望公开`2*4 "
"uint8_t`数组的`memoryview`时，可以这样做："
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:549
msgid "\"get_memoryview2d\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:551
#: ./src/3rd/pybind11/12.Python的C++接口.md:565
msgid "// buffer pointer\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:552
msgid "// shape (rows, cols)\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:553
msgid "// strides in bytes\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:558
msgid ""
"这样提供的`memoryview`不归Python管理，使用者有责任管理buffer的生命周期。在C++测删除buffer后继续使用创建的`memoryview`对象将导致未定义行为。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:560
msgid "我们也可以使用`memoryview::from_memory`创建一个一维连续数组的内存视图："
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:563
msgid "\"get_memoryview1d\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:566
msgid "// buffer size\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:571
msgid "Note: `memoryview::from_memory` is not available in Python 2."
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:573
msgid "12.3 实用工具"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:575
msgid "12.3.1 在C++中使用Python print函数"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:577
msgid ""
"C++中通常使用`std::out`输出，而Python中则通常使用`print`。因为这些方法使用不同的缓冲区，混合使用它们可能会导致输出顺序问题。为解决这个问题，pybind11提供了`py::print`函数将输出写到Python的`sys.stdout`中。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:579
msgid "函数包含了Python `print`一样的`sep`, `end`, `file`, `flush`等参数。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:582
#: ./src/3rd/pybind11/12.Python的C++接口.md:583
msgid "\"three\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:582
msgid "// 1 2.0 three\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:583
msgid "\"sep\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:583
msgid "\"-\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:583
msgid "// 1-2.0-three\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:585
msgid "\"unpacked\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:586
msgid "\"->\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:586
msgid "\"end\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:586
msgid "\"<-\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:586
msgid "// -> unpacked True <-\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:589
msgid "12.3.2 从ostream捕获标准输出"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:591
msgid ""
"C++库通常使用`std::cout`和`std::cerr`来打印输出，但它们和Python的标准`sys.stdout`和`sys.stderr`不能很好的协同工作。使用`py::print`代替库的打印是不现实的。我们可以将库函数的输出重定向到相应的Python "
"streams来处理该问题："
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:594
msgid "<pybind11/iostream.h>"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:597
msgid "// Add a scoped redirect for your noisy code\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:599
#: ./src/3rd/pybind11/12.Python的C++接口.md:616
msgid "\"noisy_func\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:601
msgid "// std::ostream&\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:602
#: ./src/3rd/pybind11/13.内嵌解释器.md:153
msgid "\"sys\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:602
msgid "\"stdout\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:602
msgid "// Python output\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:608
#: ./src/3rd/pybind11/13.内嵌解释器.md:242
msgid "**Warning**"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:610
msgid ""
"`pybind11/iostream.h`的实现不是线程安全的。多线程并发写入重定向的ostream将导致数据竞争和潜在的缓冲区溢出。因此，目前要求所有(可能的)并发重定向写入ostream都要有互斥锁保护。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:612
msgid ""
"此方法会对输出流进行刷新，并在`scoped_ostream_redirect`被销毁时根据需要进行刷新。这允许实时地重定向输出，比如输出到Jupyter "
"notebook。C++流和Python输出这两个参数是可选的，不指定时默认为标准输出。`py::scoped_estream_redirect "
"<scoped_estream_redirect>`是作用于标准错误的。可以通过`py::call_guard`来简便设置。"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:615
msgid "// Alternative: Call single function using call guard\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:621
msgid ""
"The redirection can also be done in Python with the addition of a context "
"manager, using the `py::add_ostream_redirect() <add_ostream_redirect>` "
"function:"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:624
msgid "\"ostream_redirect\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:627
msgid ""
"The name in Python defaults to `ostream_redirect` if no name is passed. This "
"creates the following context manager in Python:"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:634
msgid ""
"It defaults to redirecting both streams, though you can use the keyword "
"arguments to disable one of the streams if needed."
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:636
msgid "12.3.3 从字符串和文件执行Python表达式"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:638
msgid ""
"pybind11 provides the `eval`, `exec` and `eval_file` functions to evaluate "
"Python expressions and statements. The following example illustrates how "
"they can be used."
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:641
msgid "// At beginning of file\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:642
msgid "<pybind11/eval.h>"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:645
msgid "// Evaluate in scope of main module\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:647 ./src/test/chapter_5.md:146
msgid "\"__main__\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:647
#: ./src/3rd/pybind11/13.内嵌解释器.md:222
msgid "\"__dict__\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:648
msgid "// Evaluate an isolated expression\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:650
msgid "\"my_variable + 10\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:651
msgid "// Evaluate a sequence of statements\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:654
msgid "\"print('Hello')\\n\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:655
msgid "\"print('world!');\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:657
msgid "// Evaluate the statements in an separate Python file on disk\n"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:659
msgid "\"script.py\""
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:662
msgid ""
"C++11 raw string literals are also supported and quite handy for this "
"purpose. The only requirement is that the first statement must be on a new "
"line following the raw string delimiter `R\"(`, ensuring all lines have "
"common leading indent:"
msgstr ""

#: ./src/3rd/pybind11/12.Python的C++接口.md:665
msgid ""
"R\"(\n"
"    x = get_answer()\n"
"    if x == 42:\n"
"        print('Hello World!')\n"
"    else:\n"
"        print('Bye!')\n"
"    )\""
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:58
msgid "13. 内嵌解释器"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:60
msgid ""
"虽然pybind11主要聚焦于使用C++扩展Python，反过来也是可以的，可以内嵌Python解释器到C++程序中。前面章节讲解的pybind11内容仍然适用。本节将介绍嵌入所需的一些额外内容。"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:62
msgid "13.1 准备开始"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:64
msgid "创建一个内嵌解释器的程序，可以在Cmake中添加`pybind11::embed`来支持。"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:76
msgid "`main.cpp`的基本结构如下："
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:79
msgid "<pybind11/embed.h> // everything needed for embedding"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:83
msgid "// start the interpreter and keep it alive\n"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:85 ./src/test/chapter_5.md:138
#: ./src/test/chapter_5.md:144 ./src/test/chapter_5.md:152
#: ./src/test/chapter_5.md:164 ./src/test/chapter_5.md:171
msgid "\"Hello, World!\""
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:85
msgid "// use the Python API\n"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:89
msgid ""
"需要在使用任意Python API前初始化解释器，包括pybind11 Python函数和类。RAII "
"guard类`scoped_interpreter`可用来管理解释器的生命周期。在guard类销毁时，解释器将会关闭并占用的内存。必须在所有Python函数前调用它。"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:91
msgid "13.2 执行Python代码"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:93
msgid ""
"在12.3.3节中，我们介绍了可以使用`eval`、`exec`和`eval_file`函数来执行Python表达式或语句。下面的例子展示了附带解释器来执行Python代码的流程："
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:96
#: ./src/3rd/pybind11/13.内嵌解释器.md:113
#: ./src/3rd/pybind11/13.内嵌解释器.md:129
#: ./src/3rd/pybind11/13.内嵌解释器.md:181
#: ./src/3rd/pybind11/13.内嵌解释器.md:210
msgid "<pybind11/embed.h>"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:102
msgid ""
"R\"(\n"
"        kwargs = dict(name=\"World\", number=42)\n"
"        message = \"Hello, {name}! The answer is "
"{number}\".format(**kwargs)\n"
"        print(message)\n"
"    )\""
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:110
msgid "也可以使用pybind11 API来实现相同的功能（参考12章）。"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:121
msgid "\"Hello, {name}! The answer is {number}\""
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:126
msgid "两种方法也可以混合使用："
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:130 ./src/test/chapter_4.md:73
#: ./src/test/chapter_5.md:83
msgid "<iostream>"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:139
msgid ""
"R\"(\n"
"        message = \"Hello, {name}! The answer is "
"{number}\".format(**locals())\n"
"    )\""
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:143
#: ./src/3rd/pybind11/13.内嵌解释器.md:232
msgid "\"message\""
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:148
msgid "12.3 导入模块"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:150
msgid "使用`module_::import()`可以导入Python模块。"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:154
msgid "\"path\""
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:157
msgid "为方便起见，内嵌解释器时，会将当前工作路径包含到`sys.path`中。这样我们可以方便地导入本地Python文件。"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:160
msgid "\"\"\"calc.py located in the working directory\"\"\""
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:168
msgid "\"calc\""
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:174
msgid ""
"如果运行时源文件被修改（如被外部进程修改），可以使用`module_::reload()`重新导入模块。这在下面的场景中十分有用：有个应用程序要导入用户定义数据处理脚本，该脚本需要在用户修改后更新时。注意，这个函数不会递归地重新加载模块。"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:176
msgid "12.4 添加内嵌模块"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:178
msgid ""
"使用宏`PYBIND11_EMBEDDED_MODULE`可以添加内嵌的二进制模块。这个定义需要放在全局作用域中。定义后，他们可以向其他模块一样导入。"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:185
msgid "// `m` is a `py::module_` which is used to bind functions and classes\n"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:194
msgid "\"fast_calc\""
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:200
msgid ""
"Unlike extension modules where only a single binary module can be created, "
"on the embedded side an unlimited number of modules can be added using "
"multiple `PYBIND11_EMBEDDED_MODULE` definitions (as long as they have unique "
"names)."
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:202
msgid ""
"These modules are added to Python’s list of builtins, so they can also be "
"imported in pure Python files loaded by the interpreter. Everything "
"interacts naturally:"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:205
msgid "\"\"\"py_module.py located in the working directory\"\"\""
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:220
msgid "\"py_module\""
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:222 ./src/test/chapter_5.md:161
#: ./src/test/chapter_5.md:216 ./src/test/chapter_5.md:346
msgid "\"fmt\""
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:222
msgid "\"{} + {} = {}\""
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:226
msgid ""
"R\"(\n"
"        c = a + b\n"
"        message = fmt.format(a, b, c)\n"
"    )\""
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:231
msgid "\"c\""
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:232
msgid "\"1 + 2 = 3\""
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:236
msgid "12.5 解释器的生命周期"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:238
msgid ""
"当 `scoped_interpreter` 销毁时，程序会自动关闭Python解释器。后面再创建一个新的示例会重启解释器。或者，我们也可以使用 "
"`initialize_interpreter` / `finalize_interpreter` 这组函数在任意时刻直接设置解释器状态。"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:240
msgid ""
"解释器重启后，pybind11创建的模块可以安全地重新初始化，但第三方扩展模块可能会有些问题。问题在于Python本身不能完全卸载扩展模块，并且会有一些解释器重启的警告。简而言之，由于Python引用循环或用户创建的全局数据，并非所有内存都可能被释放。具体细节可以查看CPython文档。"
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:244
msgid ""
"Creating two concurrent `scoped_interpreter` guards is a fatal error. So is "
"calling `initialize_interpreter` for a second time after the interpreter has "
"already been initialized."
msgstr ""

#: ./src/3rd/pybind11/13.内嵌解释器.md:246
msgid ""
"Do not use the raw CPython API functions `Py_Initialize` and `Py_Finalize` "
"as these do not properly handle the lifetime of pybind11’s internal data."
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:58
msgid "14. 杂项"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:60
msgid "14.1 关于便利宏的说明"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:62 ./src/3rd/pybind11/pybind11_demo.md:1231
msgid ""
"pybind11提供了一些便利宏如`PYBIND11_DECLARE_HOLDER_TYPE()`和`PYBIND11_OVERRIDE_*`。由于这些宏只是在预处理中计算(预处理程序没有类型的概念)，它们会被模板参数中的逗号搞混。如："
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:68 ./src/3rd/pybind11/pybind11_demo.md:1237
msgid "预处理器会将其解释为5个参数（逗号分隔），而不是3个。有两种方法可以处理这个问题：使用类型别名，或者使用`PYBIND11_TYPE`包裹类型。"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:71 ./src/3rd/pybind11/pybind11_demo.md:1240
msgid "// Version 1: using a type alias\n"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:75 ./src/3rd/pybind11/pybind11_demo.md:1244
msgid "// Version 2: using the PYBIND11_TYPE macro:\n"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:81 ./src/3rd/pybind11/pybind11_demo.md:1250
msgid "`PYBIND11_MAKE_OPAQUE`宏不需要上述解决方案。"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:83
msgid "14.2 全局解释器锁（GIL）"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:85 ./src/3rd/pybind11/pybind11_demo.md:1254
msgid ""
"在Python中调用C++函数时，默认会持有GIL。`gil_scoped_release`和`gil_scoped_acquire`可以方便地在函数体中释放和获取GIL。这样长时间运行的C++代码可以通过Python线程实现并行化。示例如下："
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:95 ./src/3rd/pybind11/pybind11_demo.md:1264
msgid "/* Acquire GIL before calling Python code */"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:101 ./src/3rd/pybind11/pybind11_demo.md:1270
msgid "/* Name of function */"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:117 ./src/3rd/pybind11/pybind11_demo.md:1286
msgid "/* Release GIL before calling into (potentially long-running) C++ code */"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:124 ./src/3rd/pybind11/pybind11_demo.md:1293
msgid "我们可以使用`call_guard`策略来简化`call_go`的封装："
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:130
msgid "14.3 通过多个模块来划分代码"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:132
msgid "通常我们可以直接将绑定代码分隔到多个模块中，即便模块引用的类型在其他模块中定义。有个例外场景，就是当前扩展的类型定义在其他模块中，参见下面的例子："
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:139
msgid "/* <- specify parent */"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:144
msgid ""
"假设`Pet`类的绑定定义在`basic`模块中，而`Dog`绑定定义在其他模块。在`class_<Dog>`中明确与`Pet`类的继承关系时需要知道`Pet`，问题是在其他模块定义的`Pet`不再对`Dog`可见。我们可以这样处理："
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:147 ./src/3rd/pybind11/14.杂项.md:157
msgid "\"basic\""
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:154
msgid ""
"或者，你可以将基类作为模板参数给`class_`，让pybind11自动查找到相应的Python类型。但也需要调用一次`import`函数，确保`basic`模块的绑定代码已经执行。"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:164
msgid "如果存在循环依赖时，上述两种方法都将失效。"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:166
msgid ""
"注意，pybind11代码在编译时会默认隐藏符号的可见性（如通过GCC/Clang的`-fvisibility=hidden`标识），这会干扰访问在其他模块定义的类型的能力。这需要通过手动导出需要被其他模块访问的类型，像这样："
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:174
msgid ""
"在运行时也可以共享任意的C++对象，尽管很少用到该特性。使用capsule机制在模块间共享内部库数据，可以用来存储、修改、访问用户自定义数据。注意，一个模块能够看到其他模块的数据，仅在他们使用相同的pybind11版本编译时才能实现。参考下面的例子："
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:177 ./src/3rd/pybind11/14.杂项.md:179
msgid "\"mydata\""
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:182
msgid ""
"如果在几个单独编译的扩展模块中使用了上述代码段，第一个导入的模块将创建`MyData`实例，并和指针联系起来。后续导入的模块就可以访问该指针指向的数据了。"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:184
msgid "14.4 模块析构"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:186
msgid ""
"pybind11没有提供明确的机制在模块析构时调用清理代码。在少数需要该功能的场景下，可以使用Python "
"capsules或析构回调函数的弱引用来模仿它。"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:190 ./src/3rd/pybind11/14.杂项.md:211
msgid "// perform cleanup here -- this function is called with the GIL held\n"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:193 ./src/3rd/pybind11/14.杂项.md:202
msgid "\"_cleanup\""
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:196
msgid "该方法一个潜在地缺陷是，在cleanup函数调用时，模块公开的类实例可能仍存活着（这是否可以接受通常取决于应用程序）。"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:198
msgid "或者，我们可以将capsule存储在类型对象中，确保它不会在回收该类型的所有实例之前被调用："
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:202 ./src/3rd/pybind11/14.杂项.md:218
msgid "\"BaseClass\""
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:205
msgid ""
"上面的方法都在Python中暴露了一个`_cleanup`的危险属性，从API的角度来看，这种做法并不受欢迎（Python过早的显式调用它可能会导致未定义行为）。这可以通过使用cleanup函数回调的弱引用来规避。"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:208
msgid ""
"// Register a callback function that is invoked when the BaseClass object is "
"collected\n"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:213
msgid "// release weak reference\n"
msgstr ""

#: ./src/3rd/pybind11/14.杂项.md:216
msgid ""
"// Create a weak reference with a cleanup callback and initially leak it\n"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:58
msgid "15. 常见问题"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:60
msgid "15.1 “ImportError: dynamic module does not define init function”"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:62
msgid "确保`PYBIND11_MODULE`中指定的名称与扩展库的文件名相同（没有后缀，例如.so）。"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:63
msgid ""
"如果上述问题没有解决，您可能使用了不兼容的`Python`版本（例如，扩展库是针对`Python2`编译的，而解释器是在`Python3`的某些版本上运行的）。"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:65
msgid "15.2 “Symbol not found: \\_\\_Py_ZeroStruct \\_PyInstanceMethod_Type”"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:67 ./src/3rd/pybind11/15.FAQ.md:71
#: ./src/3rd/pybind11/15.FAQ.md:75
msgid "参见15.1"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:69
msgid "15.3 “SystemError: dynamic module not initialized properly”"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:73
msgid "15.4 导入模块时，Python解释器立即崩溃"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:77
msgid "15.5涉及引用参数的限制"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:79
msgid ""
"在`C++`中，使用可变引用或可变指针传递参数是很常见的，这两种方法都允许读取并对调用者提供的值进行写访问。这有时是出于效率原因或为了实现具有多个返回值的函数。这里有两个非常基本的例子："
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:92
msgid ""
"在`Python`中，所有参数都是通过引用传递的，因此从Python绑定此类代码时一般不会有问题。 "
"但是，某些基本`Python`类型（如`str`、`int`、`bool`、`float` "
"等）是不可变的。这意味着尝试将函数移植到`Python`后，对调用者提供的值不会产生相同的影响，事实上，它啥都没干。"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:97
msgid "# nope..\n"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:100
msgid ""
"`pybind11`也受到此类语言级约定的影响，这意味着绑定`increment`或者`increment_ptr`还将创建不修改其参数的`Python` "
"函数。虽然不方便，但一种解决方法是将不可变类型封装在允许修改的自定义类型中影响。另一种选择涉及绑定一个小包装`lambda`函数，该函数返回一个包含所有输出参数的元组 "
"（有关绑定`lambda`函数的示例，请参阅文档的其余部分）。例如："
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:111
msgid "绑定代码为:"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:121
msgid "15.6 如何减少编译时间?"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:123
msgid "在多个文件上拆分绑定代码是一种很好的做法，如下例所示： `example.cpp`"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:137
msgid "`ex1.cpp`:"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:148
msgid "`ex2.cpp`:"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:152
msgid "\"sub\""
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:159
msgid "`python`调用："
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:164
msgid "# 3\n"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:165
msgid "# 0\n"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:168
msgid "如上所示，各种`init_ex`函数应该包含在单独的文件中，这些文件可以彼此独立编译，然后链接到同一个最终共享对象中。采用这种方法将有以下好处："
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:170
msgid "减少每个编译单元的内存需求。"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:171
msgid "启用并行构建（如果需要）。"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:172
msgid "允许更快的增量构建。例如，当更改单个类定义时，只有绑定代码通常需要重新编译。"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:174
msgid "15.7 “recursive template instantiation exceeded maximum depth of 256”"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:176
msgid ""
"如果得到关于超出递归模板深度的错误，请尝试指定更大的值，例如`GCC/Clang`上的`-ftemplate-depth=1024`编译标识。其罪魁祸首通常是使用C++14模板元编程在编译时生成函数签名。"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:178
msgid ""
"15.8 “‘SomeClass’ declared with greater visibility than the type of its "
"field ‘SomeClass::member’ \\[\\-Wattributes\\]”"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:180
msgid ""
"该错误通常表示在编译时没有使用所需的`-fvisibility`标志.pybind11代码从内部强制所有内部代码的隐藏可见性，但如果非隐藏（并因此导出），代码将尝试包括 "
"pybind类型（例如，`py::object`或`py::list`）可能会遇到此警告。为了避免这种情况，请确保在编译pybind代码时指定`-fvisibility=hidden`。 "
"至于为什么`-fvisibility=hidden`是必要的，因为`pybind`模块可以在`pybind`本身的不同版本下编译，同样重要的是，一个模块中定义的符号不会与 "
"在另一个数据库中定义的潜在不兼容符号。虽然`Python`扩展模块通常加载本地化的符号（在`POSIX`系统下，通常使用带有`RTLD_local`标志的`dlopen`），但这个`Python`默认值 "
"可以改变，但当不使用`-fvisibility=hidden`时,即使不改变，也不总是足以保证所涉及符号的完全独立性. "
"此外，`-fvisibility=hidden`可以显著节省二进制大小。（有关详细信息，请参见后续章节.)"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:187
msgid "15.9 如何创建更小的二进制文件?"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:189
msgid ""
"为了完成它的工作，`pybind11` "
"广泛依赖一种称为模板元编程的编程技术，这是一种在编译时使用类型信息执行计算的方法。模板元编程通常会实例化涉及大量深度嵌套类型的代码，这些类型在编译器的优化阶段要么被完全删除，要么被缩减为仅几条指令。但是，由于这些类型的嵌套性质，编译的扩展库中生成的符号名称可能非常长。例如，包含的测试套件包含以下符号："
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:198
msgid "这是以下函数类型的展开形式："
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:212
msgid ""
"仅存储此函数的错位名称（196 字节）所需的内存大于它所代表的实际代码段（111 "
"字节）！另一方面，甚至给这个函数起个名字都是愚蠢的——毕竟，它只是一个更大的机器中的一个小齿轮，不暴露于外界。因此，我数 "
"`-fvisibility=hidden`来实现，它将默认符号可见性设置为隐藏，这对生成的扩展库的最终二进制大小有巨大影响。 （在 `Visual "
"Studio` "
"上，默认情况下符号已隐藏，因此无需在此处进行任何操作。）除了减小二进制大小之外，`-fvisibility=hidden`还可以避免在加载多个模块时出现潜在的严重问题，并且是正确 "
"pybind们通常只想为那些实际从外部调用的函数导出符号。这可以通过为`GCC`和`Clang`指定参 "
"操作所必需的。有关更多详细信息，请参阅之前的常见问题解答条目。"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:219
msgid "15.10 使用古老的基于Windows的Visual Studio 2008"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:221
msgid ""
"`Python`的官方`Windows`发行版是使用缺乏良好 `C++11`支持的真正古老版本的 `Visual "
"Studio`编译的。一些用户隐含地假设不可能将使用 `Visual Studio 2015` 构建的插件加载到使用 `Visual Studio "
"2008`编译的`Python`发行版中。但是，不存在这样的问题：接口使用不同编译器构建的`DLL`是完全合法的，并且/或`C`库。需要注意的常见问题包括在另一个共享库中使用`malloc()`编辑的非`free()` "
"内存区域，使用具有不兼容`ABI`的数据结构，等等。`pybind11` 非常小心不要犯这些类型的错误。"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:226
msgid "15.11 如何在长时间运行的函数中正确处理`Ctrl-C`？"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:228
msgid ""
"`Ctrl-C`被`Python`解释器接收，并一直保持到`GIL`被释放，所以一个长时间运行的函数不会被中断。要从函数内部中断，您可以使用 "
"PyErr_CheckSignals() 函数，该函数将判断 Python "
"端是否已发出信号。这个函数只检查一个标志，所以它的影响可以忽略不计。接收到信号后，您必须通过抛出 py::error_already_set "
"显式中断执行（这将传播现有的 KeyboardInterrupt），或者清除错误（您通常不希望这样做）："
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:234
msgid "\"long running_func\""
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:240
msgid "// Long running iteration\n"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:246
msgid "15.12 `CMake`未检测到正确的`Python`版本"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:248
msgid ""
"基于`CMake`的构建系统将尝试自动检测已安装的`Python`版本并与之链接。如果此操作失败，或者有多个版本的`Python`并找到错误的版本，请删除`CMakeCache.txt` "
"，然后将`-DPYTHON_EXECUTABLE=$(which python)`添加到`CMake`配置行。（如果您愿意，请将`$(which "
"python)`替换为`python` 的路径。）您也可以尝试`-DPYBIND11_FINDPYTHON=ON`，这将激活新的`CMake "
"FindPython`支持而不是`pybind11`的自定义搜索。需要`CMake 3.12+，3.15+`或`3.18.2+` "
"更好。您也可以在添加或查找`pybind11`之前在`CMakeLists.txt`中进行设置。"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:253
msgid "15.13 `CMake`和`pybind11`中`Python`版本检测不一致"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:255
msgid ""
"`CMake`提供的用于`Python`版本检测的函数`find_package(PythonInterp)`和`find_package(PythonLibs)`被`pybind11`修改，原因是它们不适合`pybind11` "
"的需要。相反，`pybind11`提供了自己的、更可靠的`Python`检测`CMake`代码。但是，当在安装了多个`Python`版本的系统中使用`CMake "
"Python`检测的项目中使用`pybind11`时，可能会出现冲突。 "
"如果在同一个项目中使用这两种机制，这种差异可能会导致不一致和错误。考虑在安装了`Python2.7`和`3.x`的系统中执行的以下`CMake`代码："
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:265
msgid "它将检测`Python2.7`，`pybind11`也会选择它。 相比之下，这段代码："
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:274
msgid ""
"将为`pybind11`检测`Python3.x`，之后可能会在`find_package(PythonLibs)`上崩溃。 有三种可能的解决方案："
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:277
msgid ""
"避免使用`CMake`中的`find_package(PythonInterp)`和`find_package(PythonLibs)`并依赖`pybind11`检测`Python`版本。如果这不可能，则应在包含`pybind11` "
"之前调用`CMake`机器。"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:279
msgid ""
"将`PYBIND11_FINDPYTHON`设置为`True`或在现代`CMake`上使用`find_package(Python COMPONENTS "
"Interpreter Development)` （3.12+，3.15+更好，3.18.2+ "
"最好）。在这些情况下，`Pybind11`使用新的`CMake "
"FindPython`而不是旧的、已弃用的搜索工具，并且这些模块在查找正确的`Python`方面要好得多。"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:281
msgid ""
"将`PYBIND11_NOPYTHON`设置为`TRUE`。`Pybind11`不会搜索`Python`。但是，您将不得不使用基于目标的系统，并自己进行更多设置，因为它不知道或不包含依赖于`Python` "
"的东西，例如`pybind11_add_module`。这可能非常适合集成到现有系统中，例如`scikit-build`的`Python`助手。"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:284
msgid "15.14 如何引用这个项目？"
msgstr ""

#: ./src/3rd/pybind11/15.FAQ.md:286
msgid "我们建议使用以下 BibTeX 模板在科学话语中引用 pybind11："
msgstr ""

#: ./src/3rd/pybind11/16.案例.md:58
msgid "16.案例"
msgstr ""

#: ./src/3rd/pybind11/16.案例.md:60
msgid "16.1 c/c++基本类型传递"
msgstr ""

#: ./src/3rd/pybind11/16.案例.md:62
msgid "c基本类型"
msgstr ""

#: ./src/3rd/pybind11/16.案例.md:69
msgid "c++基本类型和模板"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:58
msgid "pybind11使用指南"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:60
msgid "1. 基础用法"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:62
msgid "1.1 安装与编译"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:63
msgid ""
"在安装python3-dev和下载了pybind11源码的前提下，可以直接include "
"pybind11头文件目录和python3头文件目录即可。cmake示例如下："
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:73
msgid "1.2 绑定函数"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:87
msgid ""
"宏`PYBIND11_MODULE`会创建模块初始化函数，它在Python中`import`模块时被调用。其参数分别是模块名，类型为`py::module_`的变量（m），是创建绑定的主要接口。`module_::def()`方法，可以生成函数的绑定。"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:89
msgid "1.2.1 关键字参数"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:91
msgid "使用`py::arg`可以指定函数的参数名，Python侧调用函数时可以使用关键字参数，以增加代码的可读性。"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:97
msgid "更简洁的写法："
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:106
msgid "Python使用示例："
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:112
msgid "1.2.2 参数默认值"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:114
msgid "pybind11不能自动地提取默认参数，因为它不属于函数类型信息的一部分。我们需要借助`arg`在绑定时指定参数默认值："
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:128
msgid "1.2.3 重载函数"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:130
msgid "重载方法即拥有相同的函数名，但入参不一样的函数。"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:133
msgid ""
"在绑定重载函数时，我们需要增加函数签名相关的信息以消除歧义。绑定多个函数到同一个Python名称，将会自动创建函数重载链。Python将会依次匹配，找到最合适的重载函数。"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:136
#: ./src/3rd/pybind11/pybind11_demo.md:142
msgid "\"A function which adds two int numbers\""
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:137
#: ./src/3rd/pybind11/pybind11_demo.md:143
msgid "\"A function which adds two double numbers\""
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:148
msgid "1.3 导出变量"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:150
msgid ""
"我们可以使用`attr`函数来注册需要导出到Python模块中的C++变量。内建类型和常规对象会在指定attriutes时自动转换，也可以使用`py::cast`来显式转换。"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:169
msgid "1.4 绑定类或结构体"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:171
msgid "现在我们来绑定一个C++自定义数据结构`Pet`。定义如下："
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:201
msgid ""
"`class_`会创建C++ class或 "
"struct的绑定。`init()`方法用于创建绑定类的构造函数，它使用类构造函数的参数类型作为模板参数，并包装相应的构造函数。"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:203
msgid ""
"使用`print(p)`打印对象信息时，默认会得到一些没用的信息。我们可以绑定一个工具函数到`__repr__`方法，来返回可读性好的摘要信息。在不改变Pet类的基础上，使用一个匿名函数来完成这个功能是一个不错的选择。"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:205
msgid "Python使用示例如下；"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:219
msgid "静态成员函数需要使用`class_::def_static`来绑定。"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:221
msgid "1.4.1 成员函数"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:266
msgid ""
"相似的方法`class_::def_readwrite_static()`, `class_::def_readonly_static()` "
"`class_::def_property_static()`, "
"`class_::def_property_readonly_static()`用于绑定静态变量和属性。"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:268
msgid "1.4.2 动态属性"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:307
msgid "1.4.3 重载方法"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:309
msgid "重载类的方法同上一节的普通函数重载，这里举个实例仅供参考："
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:321
msgid "// method 1\n"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:327
msgid "// method 2\n"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:334
msgid "1.5 绑定枚举类型"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:336
msgid "对于C风格的枚举类型，绑定示例如下："
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:344
msgid "\"Flags\""
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:345
msgid "\"Read\""
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:346
msgid "\"Write\""
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:347
msgid "\"Execute\""
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:351
msgid "`enum_::export_values()`用来导出枚举项到父作用域，C++11的强枚举类型需要跳过这点。"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:353
msgid ""
"枚举类型的枚举项会被导出到类`__members__`属性中，`name`属性可以返回枚举值的名称的unicode字符串，`str(enum)`也可以做到，但两者的实现目标不同。"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:355
msgid "1.6 接收`*args`和`**kwargs`参数"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:379
msgid "2. 函数绑定进阶"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:381
msgid "2.1 返回值策略"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:439
msgid "2.2 附加的调用策略"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:484
msgid "2.3 Keyword-only参数"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:505
msgid "2.4 Positional-only参数"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:515
msgid "2.5 Non-converting参数"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:544
msgid "3. 类绑定进阶"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:546
msgid "3.1 继承与多态"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:633
msgid "3.2 Python继承C++类"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:635
msgid "对于一个拥有纯虚函数的类，使用常规的绑定方法并在Python中直接继承它会报错，因为纯虚基类是不可构造的。"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:669
msgid "这样绑定之后，用户在Python中继承实现Animal会报错，提示\"No constructor defined!\"。"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:671
msgid "这时，我们需要定义一个新的Animal类作为辅助跳板："
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:756
msgid "3.3 虚函数与继承"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:850
msgid "3.4 非公有析构函数"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:868
msgid "3.5 隐式转换"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:870
msgid "假设项目中有A和B两个类型，A可以直接转换为B。"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:893
msgid "3.6 重载操作符"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:922
msgid "#include <pybind11/operators.h>\n"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:945
msgid "3.7 深拷贝支持"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:947
msgid "Python通常在赋值中使用引用。有时需要一个真正的拷贝，以防止修改所有的拷贝实例。`copy`模块提供了这样的拷贝能力。"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:949
msgid ""
"在Python3中，带pickle支持的类自带深拷贝能力。但是，自定义`__copy__`和`__deepcopy__`方法能够提高拷贝的性能。在Python2.7中，由于pybind11只支持cPickle，要想实现深拷贝，自定义这两个方法必须实现。"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:965
msgid "3.8 多重继承"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:986
msgid "3.9 绑定protected成员函数"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:1044
msgid "3.10 绑定final类"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:1063
msgid "4. 异常处理"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:1065
msgid "4.1 C++内置异常到Python异常的转换"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:1095
msgid "4.2 注册定制异常翻译"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:1124
msgid "9.3 在C++中处理Python异常"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:1178
msgid "9.4 处理Python C API的错误"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:1196
msgid "9.5 处理unraiseable异常"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:1198
msgid ""
"如果Python调用的C++析构函数或任何标记为`noexcept(true)`的函数抛出了异常，该异常不会传播出去。如果它们在调用图中抛出或捕捉不到任何异常，c++运行时将调用std::terminate()立即终止程序。在C++析构函数中调用Python尤其需要注意异常的捕获，必须捕获所有`error_already_set`类型的异常，并使用`error_already_set::discard_as_unraisable()`来抛弃Python异常。"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:1221
msgid "5. 类型转换"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:1224
msgid "6. python C++接口"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:1227
msgid "7. 杂项"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:1229
msgid "7.1 关于便利宏的说明"
msgstr ""

#: ./src/3rd/pybind11/pybind11_demo.md:1252
msgid "7.2 全局解释器锁（GIL）"
msgstr ""

#: ./src/basic/markdown.md:58
msgid "mdbook-mermaid"
msgstr ""

#: ./src/basic/markdown.md:60
msgid "快速上手Mermaid流程图"
msgstr ""

#: ./src/basic/markdown.md:62
msgid ""
"本文主要介绍了如何快速上手 `Mermaid` "
"流程图,不用贴图上传也不用拖拉点拽绘制,基于源码实时渲染流程图,操作简单易上手,广泛被集成于主流编辑器,包括 `markdown` 写作环境."
msgstr ""

#: ./src/basic/markdown.md:64
msgid "通过本节内容你将学习到以下主要内容:"
msgstr ""

#: ./src/basic/markdown.md:66
msgid "了解什么是流程图以及`Mermaid`流程图;"
msgstr ""

#: ./src/basic/markdown.md:67
msgid "掌握并能记住如何绘制`Mermaid`流程图;"
msgstr ""

#: ./src/basic/markdown.md:68
msgid "了解 `Gitbook` 写作环境的相关集成插件."
msgstr ""

#: ./src/basic/markdown.md:70
msgid "什么是Mermaid流程图"
msgstr ""

#: ./src/basic/markdown.md:72 ./src/basic/markdown.md:115
#: ./src/basic/markdown.md:227 ./src/basic/markdown.md:525
#: ./src/basic/markdown.md:779 ./src/basic/markdown.md:943
msgid "**关键词**"
msgstr ""

#: ./src/basic/markdown.md:80
msgid "千言万语不如一张图,使用图形展示事物处理流程的图形称之为**流程图**."
msgstr ""

#: ./src/basic/markdown.md:82
msgid ""
"`Mermaid`是一个基于 `Javascript` 的图解和制图工具.它基于 `markdown` "
"语法来简化和加速生成流程图的过程,也不止于生成流程图."
msgstr ""

#: ./src/basic/markdown.md:84 ./src/basic/markdown.md:157
#: ./src/basic/markdown.md:175 ./src/basic/markdown.md:193
#: ./src/basic/markdown.md:211 ./src/basic/markdown.md:284
#: ./src/basic/markdown.md:308 ./src/basic/markdown.md:326
#: ./src/basic/markdown.md:344 ./src/basic/markdown.md:362
#: ./src/basic/markdown.md:380 ./src/basic/markdown.md:398
#: ./src/basic/markdown.md:416 ./src/basic/markdown.md:434
#: ./src/basic/markdown.md:455 ./src/basic/markdown.md:473
#: ./src/basic/markdown.md:491 ./src/basic/markdown.md:509
#: ./src/basic/markdown.md:606 ./src/basic/markdown.md:624
#: ./src/basic/markdown.md:642 ./src/basic/markdown.md:658
#: ./src/basic/markdown.md:676 ./src/basic/markdown.md:692
#: ./src/basic/markdown.md:710 ./src/basic/markdown.md:728
#: ./src/basic/markdown.md:746 ./src/basic/markdown.md:763
#: ./src/basic/markdown.md:797 ./src/basic/markdown.md:817
#: ./src/basic/markdown.md:835 ./src/basic/markdown.md:853
#: ./src/basic/markdown.md:871
msgid "**源码**"
msgstr ""

#: ./src/basic/markdown.md:95 ./src/basic/markdown.md:164
#: ./src/basic/markdown.md:182 ./src/basic/markdown.md:200
#: ./src/basic/markdown.md:218 ./src/basic/markdown.md:291
#: ./src/basic/markdown.md:315 ./src/basic/markdown.md:333
#: ./src/basic/markdown.md:351 ./src/basic/markdown.md:369
#: ./src/basic/markdown.md:387 ./src/basic/markdown.md:405
#: ./src/basic/markdown.md:423 ./src/basic/markdown.md:443
#: ./src/basic/markdown.md:462 ./src/basic/markdown.md:480
#: ./src/basic/markdown.md:498 ./src/basic/markdown.md:516
#: ./src/basic/markdown.md:613 ./src/basic/markdown.md:631
#: ./src/basic/markdown.md:649 ./src/basic/markdown.md:665
#: ./src/basic/markdown.md:683 ./src/basic/markdown.md:699
#: ./src/basic/markdown.md:717 ./src/basic/markdown.md:735
#: ./src/basic/markdown.md:753 ./src/basic/markdown.md:770
#: ./src/basic/markdown.md:806 ./src/basic/markdown.md:824
#: ./src/basic/markdown.md:842 ./src/basic/markdown.md:860
#: ./src/basic/markdown.md:878
msgid "**效果**"
msgstr ""

#: ./src/basic/markdown.md:106
msgid ""
"项目地址: "
"[https://github.com/mermaid-js/mermaid](https://github.com/mermaid-js/mermaid)"
msgstr ""

#: ./src/basic/markdown.md:107
msgid ""
"在线编辑: "
"[https://mermaidjs.github.io/mermaid-live-editor/](https://mermaidjs.github.io/mermaid-live-editor/)"
msgstr ""

#: ./src/basic/markdown.md:108
msgid ""
"官方文档: "
"[https://mermaid-js.github.io/mermaid/#/flowchart](https://mermaid-js.github.io/mermaid/#/flowchart)"
msgstr ""

#: ./src/basic/markdown.md:109
msgid ""
"官方参考: "
"[https://mermaid.nodejs.cn/syntax/flowchart.html](https://mermaid.nodejs.cn/syntax/flowchart.html)"
msgstr ""

#: ./src/basic/markdown.md:111
msgid "Mermaid流程图快速入门"
msgstr ""

#: ./src/basic/markdown.md:113
msgid "布局方向"
msgstr ""

#: ./src/basic/markdown.md:149
msgid ""
"流程图布局方向,由四种基本方向组成,分别是英文单词: `top`(上), `bottom`(下),`left`(左)和 "
"`right`(右).其中可选值: `TB` (从上到下),`BT` (从下到上),`LR` (从左往右)和 `RL` (从右往左)四种."
msgstr ""

#: ./src/basic/markdown.md:151
msgid "**核心**: 仅支持上下左右四个垂直方向,是英文单词首字母大写缩写."
msgstr ""

#: ./src/basic/markdown.md:153
msgid "TB"
msgstr ""

#: ./src/basic/markdown.md:155
msgid "从上到下: from **T**op to **B**ottom"
msgstr ""

#: ./src/basic/markdown.md:171
msgid "BT "
msgstr ""

#: ./src/basic/markdown.md:173
msgid "从下到上: from **B**ottom to **T**op"
msgstr ""

#: ./src/basic/markdown.md:189
msgid "LR"
msgstr ""

#: ./src/basic/markdown.md:191
msgid "从左往右: from **L**eft to **R**ight"
msgstr ""

#: ./src/basic/markdown.md:207
msgid "RL"
msgstr ""

#: ./src/basic/markdown.md:209
msgid "从右往左: from **R**ight to **L**eft"
msgstr ""

#: ./src/basic/markdown.md:225
msgid "形状"
msgstr ""

#: ./src/basic/markdown.md:250
msgid ""
"```mermaid\n"
"graph \n"
"    id0\n"
"    id1[矩形]\n"
"    id2(圆角矩形)\n"
"    id3([椭圆])\n"
"    id4[[矩形嵌套]]\n"
"    id5[(圆柱)]\n"
"    id6((圆))\n"
"    id7>不对称矩形]\n"
"    id8{菱形}\n"
"    id9{{六边形}}\n"
"    id10[/平行四边形1/]\n"
"    id11[\\平行四边形2\\]\n"
"    id12[/梯形1\\]\n"
"    id13[\\梯形2/]\n"
"    id14(((双圆)))\n"
"    A@{ shape: manual-file, label: \"File Handling\"}\n"
"    B@{ shape: manual-input, label: \"User Input\"}\n"
"    C@{ shape: docs, label: \"Multiple Documents\"}\n"
"    D@{ shape: procs, label: \"Process Automation\"}\n"
"    E@{ shape: paper-tape, label: \"Paper Records\"}\n"
"```"
msgstr ""

#: ./src/basic/markdown.md:274
msgid ""
"流程图节点形状,默认支持矩形和圆两种基本形状,包括基本形状的简单变体,支持嵌套组合形式,其中 `[]` 表示矩形,`()` 表示圆弧,`{}` "
"表示尖角(窃以为 `<>` 更适合)等等."
msgstr ""

#: ./src/basic/markdown.md:276
msgid "**核心**: 最外层代表主形状,内层辅助修饰."
msgstr ""

#: ./src/basic/markdown.md:278
msgid "一次性节点"
msgstr ""

#: ./src/basic/markdown.md:280
msgid "一次性节点,默认表现为矩形节点,其文本内容直接显示 `id` 的值,适合后续不会出现多次引用的情况."
msgstr ""

#: ./src/basic/markdown.md:282
msgid "`id` 建议直接写成有意义的文本描述而不是当成唯一标识."
msgstr ""

#: ./src/basic/markdown.md:298
msgid "可重复节点"
msgstr ""

#: ./src/basic/markdown.md:300
msgid "可重复节点,指定节点形状,其文本内容不再是 `id` 的值而是 `<node shape>` 的值,适合后续出现多次引用相同节点的情况."
msgstr ""

#: ./src/basic/markdown.md:302
msgid "`id` 代表节点的唯一标识,当前节点的文本描述由 `<node shape>` 的值指定,建议 `id` 写成有意义的唯一标识."
msgstr ""

#: ./src/basic/markdown.md:304 ./src/basic/markdown.md:994
msgid "矩形"
msgstr ""

#: ./src/basic/markdown.md:306
msgid ""
"一般格式: `[node description]` ,`[]` 中括号表示节点是**矩形**形状,`node description` "
"是节点的描述文本."
msgstr ""

#: ./src/basic/markdown.md:322 ./src/basic/markdown.md:995
msgid "圆角矩形"
msgstr ""

#: ./src/basic/markdown.md:324
msgid ""
"一般格式: `(node description)` ,`()` 小括号表示节点是**圆角矩形**形状,`node description` "
"是节点的描述文本."
msgstr ""

#: ./src/basic/markdown.md:340 ./src/basic/markdown.md:1018
msgid "体育场"
msgstr ""

#: ./src/basic/markdown.md:342
msgid ""
"一般格式: `([node description])` ,`()` 小括号嵌套 `[]` "
"中括号表示节点是大弧度的圆角矩形形状,也就是**体育场**形状,`node description` 是节点的描述文本."
msgstr ""

#: ./src/basic/markdown.md:358
msgid "圆柱"
msgstr ""

#: ./src/basic/markdown.md:360
msgid ""
"一般格式: `[(node description)]` ,`[]` 中括号嵌套 `()` 小括号表示节点是**圆柱**形状,`node "
"description` 是节点的描述文本."
msgstr ""

#: ./src/basic/markdown.md:376 ./src/basic/markdown.md:1017
msgid "圆形"
msgstr ""

#: ./src/basic/markdown.md:378
msgid ""
"一般格式: `((node description))` ,`()` 小括号嵌套 `()` 小括号表示节点是**圆形**形状,`node "
"description` 是节点的描述文本."
msgstr ""

#: ./src/basic/markdown.md:394
msgid "不对称矩形"
msgstr ""

#: ./src/basic/markdown.md:396
msgid ""
"一般格式: `>node description]` ,左边是右尖括号 `>` ,右边是右中括号 `]` 表示**不对称矩形**形状,`node "
"description` 是节点的描述文本."
msgstr ""

#: ./src/basic/markdown.md:412 ./src/basic/markdown.md:996
#: ./src/basic/markdown.md:997
msgid "菱形"
msgstr ""

#: ./src/basic/markdown.md:414
msgid ""
"一般格式: `{node description}` ,`{}` 大括号表示**菱形**形状,`node description` 是节点的描述文本."
msgstr ""

#: ./src/basic/markdown.md:430
msgid "六角形"
msgstr ""

#: ./src/basic/markdown.md:432
msgid ""
"一般格式: `{`{`node description`}`}` ,`{}` 大括号嵌套 `{}` 大括号表示**六角形**形状,`node "
"description` 是节点的描述文本."
msgstr ""

#: ./src/basic/markdown.md:441
msgid "`Gitbook` 语法中双大括号 `{}` 表示特殊意义,上述源码只能转义处理,实际上并不需要 `\\` 进行转义."
msgstr ""

#: ./src/basic/markdown.md:451 ./src/basic/markdown.md:469
msgid "平行四边形"
msgstr ""

#: ./src/basic/markdown.md:453
msgid ""
"一般格式: `[/node description/]` ,`[]` 中括号嵌套 `//` 左斜杠表示**左斜平行四边形**形状,`node "
"description` 是节点的描述文本."
msgstr ""

#: ./src/basic/markdown.md:471
msgid ""
"一般格式: `[\\n"
"ode description\\]` ,`[]` 中括号嵌套 `\\\\` 右斜杠表示**右斜平行四边形**形状,`node description` "
"是节点的描述文本."
msgstr ""

#: ./src/basic/markdown.md:487
msgid "梯形"
msgstr ""

#: ./src/basic/markdown.md:489
msgid ""
"一般格式: `[/node description\\]` ,`[]` 中括号嵌套 `/\\` 左右斜杠表示**上短下长梯形**形状,`node "
"description` 是节点的描述文本."
msgstr ""

#: ./src/basic/markdown.md:505
msgid "另一种梯形"
msgstr ""

#: ./src/basic/markdown.md:507
msgid ""
"一般格式: `[\\n"
"ode description/]` ,`[]` 中括号嵌套 `\\/` 右左斜杠表示**上长下短梯形**形状,`node description` "
"是节点的描述文本."
msgstr ""

#: ./src/basic/markdown.md:523
msgid "连接线"
msgstr ""

#: ./src/basic/markdown.md:598
msgid ""
"流程图连接线样式,支持实线和虚线以及有箭头样式和无箭头样式,除此之外还支持添加连接线描述文字,其中 `--` 代表实线,实线中间多一点 `-.-` "
"代表虚线,添加箭头用右尖括号 `>` ,没有箭头继续用短横线 `-`."
msgstr ""

#: ./src/basic/markdown.md:600
msgid "**核心**: 先实线再虚线,先有箭头再去箭头,左边位置添加描述文字需要区分实现还是虚线,右边位置添加描述文字格式一致."
msgstr ""

#: ./src/basic/markdown.md:602
msgid "有箭头无描述实线"
msgstr ""

#: ./src/basic/markdown.md:604
msgid "一般格式: `-->` ,其中 `--` 表示实线,`>` 表示有箭头."
msgstr ""

#: ./src/basic/markdown.md:620
msgid "无箭头实线"
msgstr ""

#: ./src/basic/markdown.md:622
msgid "一般格式: `---` ,其中 `--` 表示实线,`-` 表示无箭头."
msgstr ""

#: ./src/basic/markdown.md:638
msgid "带描述的有箭头实线"
msgstr ""

#: ./src/basic/markdown.md:640
msgid ""
"一般格式: `--connection line description-->` ,其中左边的 `--` 添加到**实线左边位置**,右边的 `-->` "
"表示**带箭头的实线**."
msgstr ""

#: ./src/basic/markdown.md:656 ./src/basic/markdown.md:690
#: ./src/basic/markdown.md:761
msgid "一般格式: `|connection line description|` ,其中 `||` 添加到**连接线右边位置**."
msgstr ""

#: ./src/basic/markdown.md:672
msgid "带描述的无箭头实线"
msgstr ""

#: ./src/basic/markdown.md:674
msgid ""
"一般格式: `--connection line description` ,其中左边的 `--` 添加到**实线左边位置**,右边的 `---` "
"表示**不带箭头的实线**."
msgstr ""

#: ./src/basic/markdown.md:706
msgid "有箭头虚线"
msgstr ""

#: ./src/basic/markdown.md:708
msgid ""
"一般格式: `-.connection line description.->` ,其中左边的 `-.` 添加到**虚线左边位置**,右边的 `.->` "
"表示**带箭头的虚线**."
msgstr ""

#: ./src/basic/markdown.md:724
msgid "有箭头加粗实线"
msgstr ""

#: ./src/basic/markdown.md:726
msgid "一般格式: `==>` ,表示加粗实线."
msgstr ""

#: ./src/basic/markdown.md:742 ./src/basic/markdown.md:759
msgid "带描述的有箭头加粗实线"
msgstr ""

#: ./src/basic/markdown.md:744
msgid ""
"一般格式: `==connection line description` ,左边的 `==` 添加到加粗实现左边,右边的 `==>` 代表加粗实线."
msgstr ""

#: ./src/basic/markdown.md:777
msgid "高级用法"
msgstr ""

#: ./src/basic/markdown.md:789
msgid ""
"```mermaid\n"
"graph LR\n"
"%% this is a comment A -- text --> B{node}\n"
"   A -- text --> B -- text2 --> C[\"This is the (text) in the box\"]\n"
"```"
msgstr ""

#: ./src/basic/markdown.md:795
msgid "多节点链式连接"
msgstr ""

#: ./src/basic/markdown.md:799
msgid "支持链式连接方式,`A-->B-->C` 等价于 `A-->B` 和 `B-->C` 形式."
msgstr ""

#: ./src/basic/markdown.md:813
msgid "多节点共同连接"
msgstr ""

#: ./src/basic/markdown.md:815
msgid "支持共同连接方式,`A-->B & C` 等价于 `A-->B` 和 `A-->C` 形式."
msgstr ""

#: ./src/basic/markdown.md:831
msgid "多节点相互连接"
msgstr ""

#: ./src/basic/markdown.md:833
msgid ""
"多节点共同连接的变体形式,`A & B --> C & D` 等价于 `A-->C` ,`A-->D`,`B-->C` 和 `B-->D` 四种组合形式."
msgstr ""

#: ./src/basic/markdown.md:849
msgid "双引号包裹特殊字符"
msgstr ""

#: ./src/basic/markdown.md:851
msgid "连接线描述文字存在特殊字符使用双引号 `\"\"` 包裹处理,如遇到 `[]` 和 `()` 以及 `{}` 等特殊字符情况."
msgstr ""

#: ./src/basic/markdown.md:855
msgid ""
"```\n"
"graph LR\n"
"    id1[\"This is the (text) in the box\"]\n"
"```"
msgstr ""

#: ./src/basic/markdown.md:862
msgid ""
"```mermaid\n"
"graph LR\n"
"    id1[\"This is the (text) in the box\"]\n"
"```"
msgstr ""

#: ./src/basic/markdown.md:867
msgid "双引号包裹转义字符"
msgstr ""

#: ./src/basic/markdown.md:869
msgid "支持 `Html` 转移字符"
msgstr ""

#: ./src/basic/markdown.md:873
msgid ""
"```\n"
"graph LR\n"
"    A[\"A double quote:#quot;\"] -->B[\"A dec char:#9829;\"]\n"
"```"
msgstr ""

#: ./src/basic/markdown.md:880
msgid ""
"```mermaid\n"
"graph LR\n"
"    A[\"A double quote:#quot;\"] -->B[\"A dec char:#9829;\"]\n"
"```"
msgstr ""

#: ./src/basic/markdown.md:885
msgid "嵌套子流程图"
msgstr ""

#: ./src/basic/markdown.md:887
msgid "**定义**"
msgstr ""

#: ./src/basic/markdown.md:895
msgid "**示例**"
msgstr ""

#: ./src/basic/markdown.md:925
msgid "注释语法"
msgstr ""

#: ./src/basic/markdown.md:927
msgid "注释以 `%%` 开头并且独占一行."
msgstr ""

#: ./src/basic/markdown.md:941
msgid "快速入门流程图回顾总结"
msgstr ""

#: ./src/basic/markdown.md:971
msgid ""
"`Mermaid` 是一款开源的制图工具,可使用 `Markdown` 语法绘制流程图,支持更改流程图节点形状,添加描述文字以及更改连接线样式等等."
msgstr ""

#: ./src/basic/markdown.md:973
msgid "英文单词缩写"
msgstr ""

#: ./src/basic/markdown.md:975
msgid "四种布局方向的值是英文单词首字母大写缩写形式,默认仅支持垂直方向."
msgstr ""

#: ./src/basic/markdown.md:977
msgid "中文"
msgstr ""

#: ./src/basic/markdown.md:977
msgid "英文"
msgstr ""

#: ./src/basic/markdown.md:977
msgid "示例"
msgstr ""

#: ./src/basic/markdown.md:979
msgid "图解"
msgstr ""

#: ./src/basic/markdown.md:979
msgid "graph"
msgstr ""

#: ./src/basic/markdown.md:979
msgid "`graph` 流程图类型标识"
msgstr ""

#: ./src/basic/markdown.md:980
msgid "子图"
msgstr ""

#: ./src/basic/markdown.md:980
msgid "subgraph"
msgstr ""

#: ./src/basic/markdown.md:980
msgid "`subgraph` 嵌套子流程图标识"
msgstr ""

#: ./src/basic/markdown.md:981
msgid "上"
msgstr ""

#: ./src/basic/markdown.md:981
msgid "top"
msgstr ""

#: ./src/basic/markdown.md:981
msgid "`TB` 或 `BT` ,从上到下或从下到上的布局方向"
msgstr ""

#: ./src/basic/markdown.md:982
msgid "下"
msgstr ""

#: ./src/basic/markdown.md:982
msgid "bottom"
msgstr ""

#: ./src/basic/markdown.md:982
msgid "`BT` 或 `TB`,从下到上或从上到下的布局方向"
msgstr ""

#: ./src/basic/markdown.md:983
msgid "左"
msgstr ""

#: ./src/basic/markdown.md:983
msgid "left"
msgstr ""

#: ./src/basic/markdown.md:983
msgid "`LR` 或 `RL`,从左往右或从右往左的布局方向"
msgstr ""

#: ./src/basic/markdown.md:984
msgid "右"
msgstr ""

#: ./src/basic/markdown.md:984
msgid "right"
msgstr ""

#: ./src/basic/markdown.md:984
msgid "`RL` 或 `LR`,从右往左或从左往右的布局方向"
msgstr ""

#: ./src/basic/markdown.md:986
msgid "几何化形状"
msgstr ""

#: ./src/basic/markdown.md:988
msgid "键盘符号形象化几何形状,组合形式表示形状的叠加,其中最外层符号是主形状,嵌套符号是辅助形状."
msgstr ""

#: ./src/basic/markdown.md:990
msgid "基本单元"
msgstr ""

#: ./src/basic/markdown.md:992 ./src/basic/markdown.md:1012
msgid "表示法"
msgstr ""

#: ./src/basic/markdown.md:992 ./src/basic/markdown.md:1012
msgid "含义"
msgstr ""

#: ./src/basic/markdown.md:992 ./src/basic/markdown.md:1012
msgid "类型"
msgstr ""

#: ./src/basic/markdown.md:992 ./src/basic/markdown.md:1012
msgid "备注"
msgstr ""

#: ./src/basic/markdown.md:994
msgid "`[]`"
msgstr ""

#: ./src/basic/markdown.md:994 ./src/basic/markdown.md:995
#: ./src/basic/markdown.md:996 ./src/basic/markdown.md:997
#: ./src/basic/markdown.md:1014 ./src/basic/markdown.md:1015
#: ./src/basic/markdown.md:1016 ./src/basic/markdown.md:1017
#: ./src/basic/markdown.md:1018 ./src/basic/markdown.md:1019
#: ./src/basic/markdown.md:1020 ./src/basic/markdown.md:1021
#: ./src/basic/markdown.md:1022
msgid "节点形状"
msgstr ""

#: ./src/basic/markdown.md:994 ./src/basic/markdown.md:995
#: ./src/basic/markdown.md:996 ./src/basic/markdown.md:998
#: ./src/basic/markdown.md:999 ./src/basic/markdown.md:1000
#: ./src/basic/markdown.md:1002 ./src/basic/markdown.md:1003
#: ./src/basic/markdown.md:1004 ./src/basic/markdown.md:1005
#: ./src/basic/markdown.md:1006 ./src/basic/markdown.md:1007
#: ./src/basic/markdown.md:1015 ./src/basic/markdown.md:1017
#: ./src/basic/markdown.md:1018 ./src/basic/markdown.md:1020
#: ./src/basic/markdown.md:1023 ./src/basic/markdown.md:1024
#: ./src/basic/markdown.md:1026 ./src/basic/markdown.md:1027
#: ./src/basic/markdown.md:1028 ./src/basic/markdown.md:1029
#: ./src/basic/markdown.md:1030 ./src/basic/markdown.md:1031
#: ./src/basic/markdown.md:1036 ./src/basic/markdown.md:1037
#: ./src/basic/markdown.md:1038 ./src/basic/markdown.md:1039
#: ./src/basic/markdown.md:1040 ./src/basic/markdown.md:1041
#: ./src/basic/markdown.md:1043
msgid "支持"
msgstr ""

#: ./src/basic/markdown.md:995
msgid "`()`"
msgstr ""

#: ./src/basic/markdown.md:996
msgid "`{}`"
msgstr ""

#: ./src/basic/markdown.md:997
msgid "`<>`"
msgstr ""

#: ./src/basic/markdown.md:997 ./src/basic/markdown.md:1001
#: ./src/basic/markdown.md:1008 ./src/basic/markdown.md:1014
#: ./src/basic/markdown.md:1016 ./src/basic/markdown.md:1019
#: ./src/basic/markdown.md:1021 ./src/basic/markdown.md:1022
#: ./src/basic/markdown.md:1025 ./src/basic/markdown.md:1032
#: ./src/basic/markdown.md:1033 ./src/basic/markdown.md:1034
#: ./src/basic/markdown.md:1035 ./src/basic/markdown.md:1042
#: ./src/basic/markdown.md:1044
msgid "不支持"
msgstr ""

#: ./src/basic/markdown.md:998 ./src/basic/markdown.md:1005
msgid "`--`"
msgstr ""

#: ./src/basic/markdown.md:998
msgid "实线"
msgstr ""

#: ./src/basic/markdown.md:998 ./src/basic/markdown.md:999
#: ./src/basic/markdown.md:1000 ./src/basic/markdown.md:1001
#: ./src/basic/markdown.md:1002 ./src/basic/markdown.md:1003
#: ./src/basic/markdown.md:1023 ./src/basic/markdown.md:1024
#: ./src/basic/markdown.md:1025 ./src/basic/markdown.md:1026
#: ./src/basic/markdown.md:1027 ./src/basic/markdown.md:1028
#: ./src/basic/markdown.md:1029 ./src/basic/markdown.md:1030
#: ./src/basic/markdown.md:1031 ./src/basic/markdown.md:1032
#: ./src/basic/markdown.md:1033 ./src/basic/markdown.md:1034
#: ./src/basic/markdown.md:1035
msgid "连接线样式"
msgstr ""

#: ./src/basic/markdown.md:999 ./src/basic/markdown.md:1006
msgid "`-.`"
msgstr ""

#: ./src/basic/markdown.md:999
msgid "虚线"
msgstr ""

#: ./src/basic/markdown.md:1000 ./src/basic/markdown.md:1007
msgid "`==`"
msgstr ""

#: ./src/basic/markdown.md:1000
msgid "加粗实线"
msgstr ""

#: ./src/basic/markdown.md:1001 ./src/basic/markdown.md:1008
msgid "`=:`"
msgstr ""

#: ./src/basic/markdown.md:1001
msgid "加粗虚线"
msgstr ""

#: ./src/basic/markdown.md:1002
msgid "`>`"
msgstr ""

#: ./src/basic/markdown.md:1002
msgid "有箭头"
msgstr ""

#: ./src/basic/markdown.md:1003
msgid "`-`"
msgstr ""

#: ./src/basic/markdown.md:1003
msgid "无箭头"
msgstr ""

#: ./src/basic/markdown.md:1004 ./src/basic/markdown.md:1036
msgid "`双竖线`"
msgstr ""

#: ./src/basic/markdown.md:1004 ./src/basic/markdown.md:1036
msgid "右边连接线描述文字"
msgstr ""

#: ./src/basic/markdown.md:1004 ./src/basic/markdown.md:1005
#: ./src/basic/markdown.md:1006 ./src/basic/markdown.md:1007
#: ./src/basic/markdown.md:1008 ./src/basic/markdown.md:1036
#: ./src/basic/markdown.md:1037 ./src/basic/markdown.md:1038
#: ./src/basic/markdown.md:1039 ./src/basic/markdown.md:1040
#: ./src/basic/markdown.md:1041 ./src/basic/markdown.md:1042
#: ./src/basic/markdown.md:1043 ./src/basic/markdown.md:1044
msgid "连接线描述文字"
msgstr ""

#: ./src/basic/markdown.md:1005
msgid "左边实线连接线描述文字"
msgstr ""

#: ./src/basic/markdown.md:1006
msgid "左边虚线连接线描述文字"
msgstr ""

#: ./src/basic/markdown.md:1007
msgid "左边加粗实线连接线描述文字"
msgstr ""

#: ./src/basic/markdown.md:1008
msgid "左边加粗虚线连接线描述文字"
msgstr ""

#: ./src/basic/markdown.md:1010
msgid "组合单元"
msgstr ""

#: ./src/basic/markdown.md:1014
msgid "`[[]]`"
msgstr ""

#: ./src/basic/markdown.md:1014
msgid "正方形"
msgstr ""

#: ./src/basic/markdown.md:1015
msgid "`[()]`"
msgstr ""

#: ./src/basic/markdown.md:1015
msgid "圆柱体"
msgstr ""

#: ./src/basic/markdown.md:1016
msgid "`[{}]`"
msgstr ""

#: ./src/basic/markdown.md:1016
msgid "棱柱体"
msgstr ""

#: ./src/basic/markdown.md:1017
msgid "`(())`"
msgstr ""

#: ./src/basic/markdown.md:1018
msgid "`([])`"
msgstr ""

#: ./src/basic/markdown.md:1019
msgid "`({})`"
msgstr ""

#: ./src/basic/markdown.md:1019 ./src/basic/markdown.md:1022
msgid "圆弧"
msgstr ""

#: ./src/basic/markdown.md:1020
msgid "`双大括号`"
msgstr ""

#: ./src/basic/markdown.md:1020
msgid "六边形"
msgstr ""

#: ./src/basic/markdown.md:1021
msgid "`{[]}`"
msgstr ""

#: ./src/basic/markdown.md:1021
msgid "正多边形"
msgstr ""

#: ./src/basic/markdown.md:1022
msgid "`{()}`"
msgstr ""

#: ./src/basic/markdown.md:1023
msgid "`-->`"
msgstr ""

#: ./src/basic/markdown.md:1023
msgid "实线带箭头"
msgstr ""

#: ./src/basic/markdown.md:1024
msgid "`---`"
msgstr ""

#: ./src/basic/markdown.md:1024
msgid "实线无箭头"
msgstr ""

#: ./src/basic/markdown.md:1025
msgid "`-.>`"
msgstr ""

#: ./src/basic/markdown.md:1025 ./src/basic/markdown.md:1026
#: ./src/basic/markdown.md:1027
msgid "虚线带箭头"
msgstr ""

#: ./src/basic/markdown.md:1026
msgid "`-.->`"
msgstr ""

#: ./src/basic/markdown.md:1027
msgid "`.->`"
msgstr ""

#: ./src/basic/markdown.md:1028
msgid "`-.-`"
msgstr ""

#: ./src/basic/markdown.md:1028 ./src/basic/markdown.md:1029
msgid "虚线无箭头"
msgstr ""

#: ./src/basic/markdown.md:1029
msgid "`.-`"
msgstr ""

#: ./src/basic/markdown.md:1030
msgid "`==>`"
msgstr ""

#: ./src/basic/markdown.md:1030
msgid "加粗实线带箭头"
msgstr ""

#: ./src/basic/markdown.md:1031
msgid "`===`"
msgstr ""

#: ./src/basic/markdown.md:1031
msgid "加粗实线无箭头"
msgstr ""

#: ./src/basic/markdown.md:1032
msgid "`=:>`"
msgstr ""

#: ./src/basic/markdown.md:1032 ./src/basic/markdown.md:1033
msgid "加粗虚线带箭头"
msgstr ""

#: ./src/basic/markdown.md:1033
msgid "`=:=>`"
msgstr ""

#: ./src/basic/markdown.md:1034
msgid "`=:=`"
msgstr ""

#: ./src/basic/markdown.md:1034 ./src/basic/markdown.md:1035
msgid "加粗虚线无箭头"
msgstr ""

#: ./src/basic/markdown.md:1035
msgid "`:=`"
msgstr ""

#: ./src/basic/markdown.md:1037
msgid "`--connection line description-->`"
msgstr ""

#: ./src/basic/markdown.md:1037
msgid "左边实线带箭头连接线描述文字"
msgstr ""

#: ./src/basic/markdown.md:1038
msgid "`-.connection line description-.->`"
msgstr ""

#: ./src/basic/markdown.md:1038
msgid "左边虚线带箭头连接线描述文字"
msgstr ""

#: ./src/basic/markdown.md:1039
msgid "`--connection line description---`"
msgstr ""

#: ./src/basic/markdown.md:1039
msgid "左边实线无箭头连接线描述文字"
msgstr ""

#: ./src/basic/markdown.md:1040
msgid "`-.connection line description-.-`"
msgstr ""

#: ./src/basic/markdown.md:1040
msgid "左边虚线无箭头连接线描述文字"
msgstr ""

#: ./src/basic/markdown.md:1041
msgid "`==connection line description==>`"
msgstr ""

#: ./src/basic/markdown.md:1041
msgid "左边加粗实线带箭头连接线描述文字"
msgstr ""

#: ./src/basic/markdown.md:1042
msgid "`=:connection line description=:=>`"
msgstr ""

#: ./src/basic/markdown.md:1042
msgid "左边加粗虚线带箭头连接线描述文字"
msgstr ""

#: ./src/basic/markdown.md:1043
msgid "`==connection line description===`"
msgstr ""

#: ./src/basic/markdown.md:1043
msgid "左边加粗实线无箭头连接线描述文字"
msgstr ""

#: ./src/basic/markdown.md:1044
msgid "`=:connection line description=:=`"
msgstr ""

#: ./src/basic/markdown.md:1044
msgid "左边加粗虚线无箭头连接线描述文字"
msgstr ""

#: ./src/basic/markdown.md:1046
msgid "有限语法"
msgstr ""

#: ./src/basic/markdown.md:1048
msgid "不论是节点形状还是连接线样式,语法支持是有限的,并不是随意组合的叠加状态,也可能随着后续更新会支持更多,一切以官方文档为主."
msgstr ""

#: ./src/basic/markdown.md:1050
msgid "除了提供最基础的操作节点的能力之外,还可以根据 `JS` 和 `CSS` 相关知识高度自定义流程图行为表现,具体可参考官方文档."
msgstr ""

#: ./src/basic/markdown.md:1052
msgid ""
"官方文档: "
"[https://mermaid-js.github.io/mermaid/#/flowchart?id=styling-and-classes](https://mermaid-js.github.io/mermaid/#/flowchart?id=styling-and-classes)"
msgstr ""

#: ./src/basic/markdown.md:1054
msgid ""
"交互能力 Interaction : "
"[https://mermaid-js.github.io/mermaid/#/flowchart?id=interaction](https://mermaid-js.github.io/mermaid/#/flowchart?id=interaction)"
msgstr ""

#: ./src/basic/markdown.md:1055
msgid ""
"外观样式 Styling and classes : "
"[https://mermaid-js.github.io/mermaid/#/flowchart?id=interaction](https://mermaid-js.github.io/mermaid/#/flowchart?id=interaction)"
msgstr ""

#: ./src/basic/markdown.md:1056
msgid ""
"字体支持 Basic support for fontawesome: "
"[https://mermaid-js.github.io/mermaid/#/flowchart?id=basic-support-for-fontawesome](https://mermaid-js.github.io/mermaid/#/flowchart?id=basic-support-for-fontawesome)"
msgstr ""

#: ./src/basic/markdown.md:1057
msgid ""
"空格分隔 "
"[https://mermaid-js.github.io/mermaid/#/flowchart?id=graph-declarations-with-spaces-between-vertices-and-link-and-without-semicolon](https://mermaid-js.github.io/mermaid/#/flowchart?id=graph-declarations-with-spaces-between-vertices-and-link-and-without-semicolon)"
msgstr ""

#: ./src/basic/admonish.md:58
msgid "mdbook-admonish"
msgstr ""

#: ./src/basic/admonish.md:60
msgid ""
"The following admonishments are implemented by the "
"[mdbook-admonish](https://github.com/tommilligan/mdbook-admonish) plugin and "
"are automatically themed to match Catppuccin."
msgstr ""

#: ./src/basic/admonish.md:64
msgid "Directives"
msgstr ""

#: ./src/basic/admonish.md:66
msgid "All supported directives are listed below."
msgstr ""

#: ./src/basic/admonish.md:68
msgid "`note`"
msgstr ""

#: ./src/basic/admonish.md:74
msgid "`abstract`, `summary`, `tldr`"
msgstr ""

#: ./src/basic/admonish.md:80
msgid "`info`, `todo`"
msgstr ""

#: ./src/basic/admonish.md:86
msgid "`tip`, `hint`, `important`"
msgstr ""

#: ./src/basic/admonish.md:92
msgid "`success`, `check`, `done`"
msgstr ""

#: ./src/basic/admonish.md:98
msgid "`question`, `help`, `faq`"
msgstr ""

#: ./src/basic/admonish.md:104
msgid "`warning`, `caution`, `attention`"
msgstr ""

#: ./src/basic/admonish.md:110
msgid "`failure`, `fail`, `missing`"
msgstr ""

#: ./src/basic/admonish.md:116
msgid "`danger`, `error`"
msgstr ""

#: ./src/basic/admonish.md:122
msgid "`bug`"
msgstr ""

#: ./src/basic/admonish.md:128
msgid "`example`"
msgstr ""

#: ./src/basic/admonish.md:134
msgid "`quote`, `cite`"
msgstr ""

#: ./src/basic/admonish.md:140
msgid "Bienvenue sur notre site de développement 3D !"
msgstr ""

#: ./src/basic/admonish.md:142
msgid ""
"Bienvenue sur notre site dédié au développement 3D. Ici, vous trouverez des "
"ressources, des tutoriels et des informations utiles pour vous lancer dans "
"le monde passionnant de la 3D."
msgstr ""

#: ./src/basic/admonish.md:148
msgid ""
"```admonish example \"Un example\"\n"
"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod\n"
"nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor\n"
"massa, nec semper lorem quam in massa.\n"
"```"
msgstr ""

#: ./src/basic/admonish.md:154
msgid ""
"```admonish note \"Une note\"\n"
"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod\n"
"nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor\n"
"massa, nec semper lorem quam in massa.\n"
"```"
msgstr ""

#: ./src/basic/admonish.md:160
msgid ""
"```admonish warning \"Un warning\"\n"
"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod\n"
"nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor\n"
"massa, nec semper lorem quam in massa.\n"
"```"
msgstr ""

#: ./src/basic/admonish.md:166
msgid ""
"```admonish note collapsible=true title=\"Collapsing note\"\n"
"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod\n"
"nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor\n"
"massa, nec semper lorem quam in massa.\n"
"```"
msgstr ""

#: ./src/basic/admonish.md:172
msgid ""
"```admonish danger \"Le javascript c'est yolo préférez Typescript\"\n"
"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod\n"
"nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor\n"
"massa, nec semper lorem quam in massa.\n"
"```"
msgstr ""

#: ./src/basic/admonish.md:178
msgid ""
"```admonish tip title=\"_Referencing_ and <i>dereferencing</i>\"\n"
"The opposite of *referencing* by using `&` is *dereferencing*, which is\n"
"accomplished with the <span style=\"color: hotpink\">dereference "
"operator</span>, `*`.\n"
"```"
msgstr ""

#: ./src/basic/admonish.md:183
msgid ""
"```admonish bug\n"
"This syntax won't work in Python 3:\n"
"```python\n"
"print \"Hello, world!\"\n"
"```\n"
"```"
msgstr ""

#: ./src/basic/admonish.md:190
msgid "À propos de nous"
msgstr ""

#: ./src/basic/admonish.md:192
msgid ""
"Nous sommes une équipe passionnée par la 3D et nous avons pour mission de "
"partager nos connaissances avec la communauté. Vous trouverez ici des "
"articles, des exemples de code et des démonstrations pour vous aider à "
"démarrer votre voyage dans le développement 3D."
msgstr ""

#: ./src/basic/admonish.md:203
msgid "Pour commencer"
msgstr ""

#: ./src/basic/admonish.md:205
msgid ""
"Si vous êtes nouveau dans le domaine de la 3D, ne vous inquiétez pas ! Notre "
"page [\"Getting Started\"](getting-started/getting-started.md) vous guidera "
"à travers les étapes essentielles pour démarrer rapidement."
msgstr ""

#: ./src/basic/admonish.md:207
msgid "Restons en contact"
msgstr ""

#: ./src/basic/admonish.md:209
msgid ""
"N'hésitez pas à nous suivre sur les réseaux sociaux pour rester à jour avec "
"nos dernières publications et annonces. Si vous avez des questions ou des "
"commentaires, n'hésitez pas à nous contacter !"
msgstr ""

#: ./src/basic/admonish.md:211
msgid "Mizux"
msgstr ""

#: ./src/test/chapter_3.md:58
msgid "mdbook-katex"
msgstr ""

#: ./src/test/chapter_3.md:60
msgid "HTML:"
msgstr ""

#: ./src/test/chapter_3.md:62 ./src/test/chapter_3.md:62
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74
msgid "e"
msgstr ""

#: ./src/test/chapter_3.md:62 ./src/test/chapter_3.md:62
#: ./src/test/chapter_3.md:62 ./src/test/chapter_3.md:62
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:81 ./src/test/chapter_3.md:81
#: ./src/test/chapter_3.md:87 ./src/test/chapter_3.md:87
msgid "i"
msgstr ""

#: ./src/test/chapter_3.md:62 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74
msgid "cos"
msgstr ""

#: ./src/test/chapter_3.md:62 ./src/test/chapter_3.md:62
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
msgid "+"
msgstr ""

#: ./src/test/chapter_3.md:62 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74
msgid "sin"
msgstr ""

#: ./src/test/chapter_3.md:62
msgid "⇒"
msgstr ""

#: ./src/test/chapter_3.md:62 ./src/test/chapter_3.md:66
msgid "y"
msgstr ""

#: ./src/test/chapter_3.md:62
msgid "r"
msgstr ""

#: ./src/test/chapter_3.md:64
msgid "Markdown (requires `mdbook-katex`):"
msgstr ""

#: ./src/test/chapter_3.md:66
msgid "∮"
msgstr ""

#: ./src/test/chapter_3.md:66
msgid "C"
msgstr ""

#: ./src/test/chapter_3.md:66 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:81
#: ./src/test/chapter_3.md:81 ./src/test/chapter_3.md:81
#: ./src/test/chapter_3.md:81 ./src/test/chapter_3.md:87
#: ./src/test/chapter_3.md:87 ./src/test/chapter_3.md:87
#: ./src/test/chapter_3.md:87 ./src/test/chapter_3.md:87
#: ./src/test/chapter_3.md:87 ./src/test/chapter_3.md:87
#: ./src/test/chapter_3.md:87 ./src/test/chapter_3.md:87
#: ./src/test/chapter_3.md:87 ./src/test/chapter_3.md:87
msgid "​"
msgstr ""

#: ./src/test/chapter_3.md:66 ./src/test/chapter_3.md:81
#: ./src/test/chapter_3.md:81
msgid "d"
msgstr ""

#: ./src/test/chapter_3.md:66
msgid "A"
msgstr ""

#: ./src/test/chapter_3.md:68
msgid ""
"Inspect element and use `Sources` tab (under `Debugger` on Firefox) to check "
"that all CSS and fonts are properly loaded from GitHub pages instead of "
"external CDN."
msgstr ""

#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:87
#: ./src/test/chapter_3.md:87 ./src/test/chapter_3.md:87
#: ./src/test/chapter_3.md:87 ./src/test/chapter_3.md:87
#: ./src/test/chapter_3.md:87
msgid "0"
msgstr ""

#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74
msgid "∑"
msgstr ""

#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:81
#: ./src/test/chapter_3.md:81 ./src/test/chapter_3.md:81
#: ./src/test/chapter_3.md:81
msgid "∞"
msgstr ""

#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74
msgid "!"
msgstr ""

#: ./src/test/chapter_3.md:74
msgid "⟹"
msgstr ""

#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74
msgid "m"
msgstr ""

#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
msgid ")!"
msgstr ""

#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:81 ./src/test/chapter_3.md:81
#: ./src/test/chapter_3.md:81 ./src/test/chapter_3.md:87
#: ./src/test/chapter_3.md:87
msgid "−"
msgstr ""

#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:87 ./src/test/chapter_3.md:87
#: ./src/test/chapter_3.md:87 ./src/test/chapter_3.md:87
#: ./src/test/chapter_3.md:87
msgid "1"
msgstr ""

#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
msgid "s"
msgstr ""

#: ./src/test/chapter_3.md:74 ./src/test/chapter_3.md:74
#: ./src/test/chapter_3.md:74
msgid "l"
msgstr ""

#: ./src/test/chapter_3.md:79
msgid "Fourier Transform:"
msgstr ""

#: ./src/test/chapter_3.md:81 ./src/test/chapter_3.md:81
#: ./src/test/chapter_3.md:81 ./src/test/chapter_3.md:81
#: ./src/test/chapter_3.md:81
msgid "t"
msgstr ""

#: ./src/test/chapter_3.md:81 ./src/test/chapter_3.md:81
msgid "F"
msgstr ""

#: ./src/test/chapter_3.md:81 ./src/test/chapter_3.md:81
#: ./src/test/chapter_3.md:81 ./src/test/chapter_3.md:81
#: ./src/test/chapter_3.md:81
msgid "ω"
msgstr ""

#: ./src/test/chapter_3.md:81 ./src/test/chapter_3.md:81
msgid "∫"
msgstr ""

#: ./src/test/chapter_3.md:81 ./src/test/chapter_3.md:81
msgid "4"
msgstr ""

#: ./src/test/chapter_3.md:85
msgid "Pauli Matrices:"
msgstr ""

#: ./src/test/chapter_3.md:87 ./src/test/chapter_3.md:87
#: ./src/test/chapter_3.md:87
msgid "σ"
msgstr ""

#: ./src/test/chapter_3.md:87
msgid "3"
msgstr ""

#: ./src/test/chapter_4.md:58
msgid "mdbook-whichlang"
msgstr ""

#: ./src/test/chapter_4.md:63
msgid "<stdio.h>"
msgstr ""

#: ./src/test/chapter_4.md:66
msgid "\"Hello World\\n\""
msgstr ""

#: ./src/test/chapter_4.md:77 ./src/test/chapter_4.md:84
#: ./src/test/chapter_4.md:116 ./src/test/chapter_4.md:122
#: ./src/test/chapter_5.md:79
msgid "\"Hello World\""
msgstr ""

#: ./src/test/chapter_4.md:89
msgid ""
"```typescript\n"
"console.log(\"Hello World\");\n"
"```"
msgstr ""

#: ./src/test/chapter_4.md:95
msgid ""
"```rescript\n"
"Console.log(\"Hello World\")\n"
"```"
msgstr ""

#: ./src/test/chapter_4.md:127
msgid ""
"```nim\n"
"echo \"Hello World\"\n"
"```"
msgstr ""

#: ./src/test/chapter_4.md:133
msgid ""
"```zig,fp=hello.zig\n"
"const std = @import(\"std\");\n"
"\n"
"pub fn main() !void {\n"
"    const stdout = std.io.getStdOut().writer();\n"
"    try stdout.print(\"Hello, {s}!\\n"
"\", .{\"world\"});\n"
"}\n"
"```"
msgstr ""

#: ./src/test/chapter_4.md:144
msgid ""
"```odin\n"
"package main\n"
"\n"
"import \"core:fmt\"\n"
"\n"
"main :: proc() {\n"
"\tfmt.println(\"Hellope!\")\n"
"}\n"
"```"
msgstr ""

#: ./src/test/chapter_4.md:156
msgid ""
"```wat,fp=hello.wat,icon=%webassembly\n"
"(module\n"
"    (import \"wasi_unstable\" \"fd_write\"\n"
"        (func $fd_write (param i32 i32 i32 i32) (result i32))\n"
"    )\n"
"\n"
"    (memory 1)\n"
"    (export \"memory\" (memory 0))\n"
"\n"
"    (data (i32.const 0) \"\\08\\00\\00\\00\\0c\\00\\00\\00Hello World\\n"
"\")\n"
"\n"
"    (func $main (export \"_start\")\n"
"        i32.const 1\n"
"        i32.const 0\n"
"        i32.const 1\n"
"        i32.const 20\n"
"        call $fd_write\n"
"        drop\n"
"    )\n"
")\n"
"```"
msgstr ""

#: ./src/test/chapter_5.md:58
msgid "mdbook-langtabs"
msgstr ""

#: ./src/test/chapter_5.md:60
msgid "Some code"
msgstr ""

#: ./src/test/chapter_5.md:62
msgid "let's try with a simple example:"
msgstr ""

#: ./src/test/chapter_5.md:66
msgid ""
"```swift reds\n"
"LogChannel(n\"DEBUG\", \"hello world\");\n"
"```"
msgstr ""

#: ./src/test/chapter_5.md:70
msgid ""
"```swift\n"
"print(\"Hello, World!\") \n"
"```"
msgstr ""

#: ./src/test/chapter_5.md:75
msgid "\"hello world\""
msgstr ""

#: ./src/test/chapter_5.md:86
msgid "\"Hello World!\""
msgstr ""

#: ./src/test/chapter_5.md:92
msgid "some"
msgstr ""

#: ./src/test/chapter_5.md:93
msgid "interesting"
msgstr ""

#: ./src/test/chapter_5.md:94
msgid "property"
msgstr ""

#: ./src/test/chapter_5.md:99
msgid "\"some\""
msgstr ""

#: ./src/test/chapter_5.md:99
msgid "\"interesting\""
msgstr ""

#: ./src/test/chapter_5.md:99
msgid "\"property\""
msgstr ""

#: ./src/test/chapter_5.md:113
msgid "contrary to code blocks, `inline` and `fenced` are left untouched."
msgstr ""

#: ./src/test/chapter_5.md:116
msgid "it should also work when deeply nested:"
msgstr ""

#: ./src/test/chapter_5.md:118
msgid "outer:"
msgstr ""

#: ./src/test/chapter_5.md:119
msgid "inner:"
msgstr ""

#: ./src/test/chapter_5.md:121
msgid ""
"```swift reds\n"
"GameInstance\n"
"  .GetStatusEffectSystem(this.GetGame())\n"
"  .ApplyStatusEffect(\n"
"    this.GetEntityID(),\n"
"    t\"BaseStatusEffect.SplinterAddicted\",\n"
"    this.GetRecordID(),\n"
"    this.GetEntityID());\n"
"```"
msgstr ""

#: ./src/test/chapter_5.md:131
msgid "Hello World"
msgstr ""

#: ./src/test/chapter_5.md:133
msgid "Here's a simple \"Hello World\" example in different languages:"
msgstr ""

#: ./src/test/chapter_5.md:177
msgid "Simple Function Example"
msgstr ""

#: ./src/test/chapter_5.md:179
msgid ""
"Here's how you might define a function to calculate factorial in different "
"languages:"
msgstr ""

#: ./src/test/chapter_5.md:191
msgid "\"5! = {}\""
msgstr ""

#: ./src/test/chapter_5.md:191 ./src/test/chapter_5.md:210
#: ./src/test/chapter_5.md:226 ./src/test/chapter_5.md:238
msgid "// Outputs: 5! = 120\n"
msgstr ""

#: ./src/test/chapter_5.md:201
msgid "\"5! = "
msgstr ""

#: ./src/test/chapter_5.md:201 ./src/test/chapter_5.md:307
msgid "\""
msgstr ""

#: ./src/test/chapter_5.md:201
msgid "# Outputs: 5! = 120\n"
msgstr ""

#: ./src/test/chapter_5.md:210
msgid "`5! = "
msgstr ""

#: ./src/test/chapter_5.md:210 ./src/test/chapter_5.md:339
msgid "`"
msgstr ""

#: ./src/test/chapter_5.md:226
msgid "\"5! = %d\\n\""
msgstr ""

#: ./src/test/chapter_5.md:238
msgid "\"5! = \""
msgstr ""

#: ./src/test/chapter_5.md:244
msgid "Data Structures Example"
msgstr ""

#: ./src/test/chapter_5.md:246
msgid "Here's how you might implement a simple stack in different languages:"
msgstr ""

#: ./src/test/chapter_5.md:279
msgid "\"Popped: {}\""
msgstr ""

#: ./src/test/chapter_5.md:299
msgid "# Usage\n"
msgstr ""

#: ./src/test/chapter_5.md:307
msgid "\"Popped: "
msgstr ""

#: ./src/test/chapter_5.md:331
msgid "// Usage\n"
msgstr ""

#: ./src/test/chapter_5.md:339
msgid "`Popped: "
msgstr ""

#: ./src/test/chapter_5.md:379
msgid "\"Popped: %d\\n\""
msgstr ""

#: ./src/test/chapter_5.md:414
msgid "\"Popped: \""
msgstr ""

#: ./src/test/chapter_2.md:59
msgid "kroki"
msgstr ""

